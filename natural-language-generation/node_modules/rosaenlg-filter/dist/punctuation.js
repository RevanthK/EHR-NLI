"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
const constants_2 = require("./constants");
exports.EATSPACE = 'EATSPACE';
function duplicatePunctuation(input, lang) {
    let res = input;
    // ['bla ...', 'bla…'],
    res = res.replace(/\.\.\./g, '…');
    // ['bla ! . bla', 'Bla! Bla'],
    const regexDoublePunct = new RegExp(`([${constants_2.allPunctList}])((?:${constants_2.spaceOrNonBlockingClass}*[${constants_2.allPunctList}])*)`, 'g');
    res = res.replace(regexDoublePunct, function (match, firstPunct, otherStuff) {
        const regexRemovePunct = new RegExp(`[${constants_2.allPunctList}]`, 'g');
        const removedPunct = otherStuff.replace(regexRemovePunct, function ( /*match: string*/) {
            return '';
        });
        return `${firstPunct}${removedPunct}`;
    });
    return res;
}
exports.duplicatePunctuation = duplicatePunctuation;
function cleanSpacesPunctuation(input, lang) {
    let res = input;
    // 2 spaces or more
    res = res.replace(/\s{2,}/g, ' ');
    switch (lang) {
        case 'fr_FR':
            // all but . and ,
            const regexAllButDot = new RegExp(`(${constants_2.spaceOrNonBlockingClass}*)([:!\\?;])(${constants_2.spaceOrNonBlockingClass}*)`, 'g');
            res = res.replace(regexAllButDot, function (match, before, punc, after) {
                // console.log(`${match} <${before}> <${after}>`);
                return `${before.replace(/\s/g, '')}\xa0${punc} ${after.replace(/\s/g, '')}`;
            });
            // . and , and …
            const regexDot = new RegExp(`(${constants_2.spaceOrNonBlockingClass}*)([\\.,…])(${constants_2.spaceOrNonBlockingClass}*)`, 'g');
            res = res.replace(regexDot, function (match, before, punc, after) {
                // console.log(`${match} <${before}> <${after}>`);
                return `${before.replace(/\s/g, '')}${punc} ${after.replace(/\s/g, '')}`;
            });
            //console.log('xxx ' + res);
            break;
        case 'en_US':
        case 'it_IT':
        case 'de_DE':
        default:
            //console.log(res);
            const regexPunct = new RegExp(`(${constants_2.spaceOrNonBlockingClass}*)([${constants_2.allPunctList}])(${constants_2.spaceOrNonBlockingClass}*)`, 'g');
            res = res.replace(regexPunct, function (match, before, punct, after) {
                return `${before.replace(/\s/g, '')}${punct} ${after.replace(/\s/g, '')}`;
            });
            break;
    }
    res = res.replace(/\s+☚/g, '☚');
    // ['bla  .   </p>', 'bla.</p>']
    res = res.replace(/☛\s+/g, '☛');
    res = res.replace(/\s+☚/g, '☚');
    // spaces at the very end
    res = res.trim();
    // eat spaces
    const eatspaceRe = new RegExp(`[\\s¤]+${exports.EATSPACE}[\\s¤]+`, 'g');
    res = res.replace(eatspaceRe, '');
    if (lang === 'en_US') {
        // ['the phone \'s', 'The phone\'s'],
        res = res.replace(/\s*'/g, "'");
    }
    return res;
}
exports.cleanSpacesPunctuation = cleanSpacesPunctuation;
function parenthesis(input /*, lang: string*/) {
    let res = input;
    // remove spaces after '(' or before ')'
    res = res.replace(/\(\s+/g, '(');
    res = res.replace(/\s+\)/g, ')');
    // add spaces before '(' or after ')'
    const regexSpaceBeforePar = new RegExp('[' + constants_1.tousCaracteresMinMajRe + ']\\(', 'g');
    res = res.replace(regexSpaceBeforePar, function (corresp) {
        // debug("BBB :<" + corresp + ">");
        return corresp.charAt(0) + ' (';
    });
    const regexSpaceAfterPar = new RegExp('\\)[' + constants_1.tousCaracteresMinMajRe + ']', 'g');
    res = res.replace(regexSpaceAfterPar, function (corresp) {
        // debug("BBB :<" + corresp + "><" + first + '>');
        return ') ' + corresp.charAt(1);
    });
    return res;
}
exports.parenthesis = parenthesis;
function quotes(input /*, lang: string*/) {
    let res = input;
    const regexQuotes = new RegExp(`(\\s*)"(\\s*)`, 'g');
    let alreadyStarted = false;
    res = res.replace(regexQuotes, function ( /*corresp, before, after*/) {
        if (!alreadyStarted) {
            alreadyStarted = true;
            return ' "';
        }
        else {
            alreadyStarted = false;
            return '" ';
        }
    });
    // trigger a warning if an end is missing
    if (alreadyStarted) {
        console.log(`WARNING: did find a starting " but not the ending one`);
    }
    return res;
}
exports.quotes = quotes;
function addCaps(input /*, lang: string*/) {
    let res = input;
    const triggerCaps = '[\\.!\\?]';
    {
        const regexCapsAfterDot = new RegExp(`(${triggerCaps})(${constants_2.spaceOrNonBlockingClass}*)([${constants_1.tousCaracteresMinMajRe}])`, 'g');
        res = res.replace(regexCapsAfterDot, function (corresp, punct, before, firstWord) {
            return `${punct}${before.replace(/\s/g, '')} ${firstWord.toUpperCase()}`;
        });
    }
    {
        const regexCapsAfterP = new RegExp(`([☛☚])(${constants_2.spaceOrNonBlockingClass}*)([${constants_1.tousCaracteresMinMajRe}])`, 'g');
        res = res.replace(regexCapsAfterP, function (match, start, between, char) {
            return `${start}${between.replace(/ /g, '')}${char.toUpperCase()}`;
        });
    }
    return res;
}
exports.addCaps = addCaps;
//# sourceMappingURL=punctuation.js.map