"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const french_h_muet_aspire_1 = require("french-h-muet-aspire");
const constants_1 = require("./constants");
function contractions(input) {
    let res = input;
    // de + voyelle, que + voyelle, etc.
    {
        const contrList = [
            '[Dd]e',
            '[Qq]ue',
            '[Ll]e',
            '[Ll]a',
            '[Ss]e',
            '[Jj]e',
            '[Tt]e',
            '[Mm]e',
            '[Nn]e',
            '[Pp]uisque',
            '[Jj]usque',
            '[Ll]orsque',
        ];
        for (let i = 0; i < contrList.length; i++) {
            // gérer le cas où 'de' est en début de phrase
            const regexDe = new RegExp(`${constants_1.stdBeforeWithParenthesis}(${contrList[i]})${constants_1.stdBetweenWithParenthesis}([${constants_1.toutesVoyellesMinMaj}h][${constants_1.tousCaracteresMinMajRe}]*)`, 'g');
            res = res.replace(regexDe, function (corresp, before, determiner, between, word) {
                const newBetween = between.replace(/ /g, ''); // we contract thus keep no space
                if (!french_h_muet_aspire_1.isHAspire(word)) {
                    return `${before}${determiner.substring(0, determiner.length - 1)}'${newBetween}${word}`;
                }
                else {
                    // do nothing
                    return `${before}${newBetween}${determiner} ${word}`;
                }
            });
        }
    }
    // ce arbre => cet arbre
    {
        const regexCe = new RegExp(`${constants_1.stdBeforeWithParenthesis}([Cc]e)${constants_1.stdBetweenWithParenthesis}([${constants_1.toutesVoyellesMinMaj}h][${constants_1.tousCaracteresMinMajRe}]*)`, 'g');
        res = res.replace(regexCe, function (corresp, before, determiner, between, word) {
            // debug(`${before} ${determiner} ${word}`);
            const newBetween = between;
            if (!french_h_muet_aspire_1.isHAspire(word)) {
                return `${before}${determiner}t${newBetween}${word}`;
            }
            else {
                // do nothing
                return `${before}${determiner}${newBetween}${word}`;
            }
        });
    }
    {
        const contrList = [
            ['de', 'le', 'du'],
            ['de', 'les', 'des'],
            ['de', 'lequel', 'duquel'],
            ['de', 'lesquels', 'desquels'],
            ['de', 'lesquelles', 'desquelles'],
            ['des', 'les', 'des'],
            ['à', 'le', 'au'],
            ['à', 'lequel', 'auquel'],
            ['à', 'les', 'aux'],
            ['à', 'lesquels', 'auxquels'],
            ['à', 'lesquelles', 'auxquelles'],
        ];
        for (let i = 0; i < contrList.length; i++) {
            const rawFirstPart = contrList[i][0];
            // de => [d|D]e
            const firstPart = `[${rawFirstPart.substring(0, 1)}|${rawFirstPart
                .substring(0, 1)
                .toUpperCase()}]${rawFirstPart.substring(1)}`;
            // console.log(firstPart);
            const secondPart = contrList[i][1];
            const replacer = contrList[i][2];
            const regexContr = new RegExp(`${constants_1.stdBeforeWithParenthesis}(${firstPart})${constants_1.stdBetweenWithParenthesis}${secondPart}${constants_1.stdBetweenWithParenthesis}`, 'g');
            res = res.replace(regexContr, function (match, before, part1, between, after) {
                const isUc = part1.substring(0, 1).toLowerCase() != part1.substring(0, 1);
                const newDet = isUc ? replacer.substring(0, 1).toUpperCase() + replacer.substring(1) : replacer;
                //return `${before}des ${(between + after).replace(/ /g, '')}`;
                return `${before}${newDet}${between}${after}`;
            });
        }
    }
    return res;
}
exports.contractions = contractions;
//# sourceMappingURL=french.js.map