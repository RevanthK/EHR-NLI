"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tokenizer = require("wink-tokenizer");
const stopwordsFr = require("stopwords-fr");
const stopwordsDe = require("stopwords-de");
const stopwordsEn = require("stopwords-en");
const stopwordsIt = require("stopwords-it");
const englishStemmer = require("snowball-stemmer.jsx/dest/english-stemmer.common.js");
const frenchStemmer = require("snowball-stemmer.jsx/dest/french-stemmer.common.js");
const germanStemmer = require("snowball-stemmer.jsx/dest/german-stemmer.common.js");
const italianStemmer = require("snowball-stemmer.jsx/dest/italian-stemmer.common.js");
const rosaenlg_filter_1 = require("rosaenlg-filter");
const fullySupportedLanguages = ['en_US', 'de_DE', 'fr_FR', 'it_IT'];
// exported for testing purposes
function getStandardStopWords(lang) {
    switch (lang) {
        case 'en_US':
            return stopwordsEn;
        case 'fr_FR':
            return stopwordsFr;
        case 'de_DE':
            return stopwordsDe;
        case 'it_IT':
            return stopwordsIt;
        default:
            return [];
    }
}
exports.getStandardStopWords = getStandardStopWords;
function getStopWords(lang, stopWordsToAdd, stopWordsToRemove, stopWordsOverride) {
    let baseList;
    // the base list
    if (stopWordsOverride) {
        baseList = stopWordsOverride.slice(0);
    }
    else {
        baseList = getStandardStopWords(lang);
    }
    // remove
    if (stopWordsToRemove) {
        baseList = baseList.filter(function (word) {
            return !stopWordsToRemove.includes(word);
        });
    }
    // and add
    if (stopWordsToAdd) {
        baseList = baseList.concat(stopWordsToAdd);
    }
    return baseList.map(function (alt) {
        return alt.toLowerCase();
    });
}
exports.getStopWords = getStopWords;
function extractWords(input, lang) {
    // console.log(`tokenizing: ${input}`);
    const myTokenizer = new tokenizer();
    myTokenizer.defineConfig({
        currency: false,
        number: false,
        punctuation: false,
        symbol: false,
        time: false,
    });
    const tokenized = myTokenizer.tokenize(input);
    // console.log(`tokenized: ${tokenized}`);
    let res = [];
    tokenized.forEach(function (elt) {
        // no alien tags and no html elements
        if (elt.tag != 'alien' && rosaenlg_filter_1.blockLevelHtmlElts.indexOf(elt.value) == -1 && rosaenlg_filter_1.inlineHtmlElts.indexOf(elt.value) == -1) {
            res.push(elt.value);
        }
    });
    if (lang == 'fr_FR') {
        // we just leave [Pp]uisqu [Jj]usqu [Ll]orsqu as they are
        const regexp = new RegExp("^(D|d|Q|q|L|l|S|s|J|j|T|t|M|m|N|n)'", 'g');
        res = res.map((elt) => {
            return elt.replace(regexp, '');
        });
        // sometimes it results in having empty elements
        res = res.filter(elt => elt.length > 0);
    }
    // console.log(`res: ${res}`);
    return res;
}
exports.extractWords = extractWords;
const stemmersCache = {};
function stemWordForLang(word, lang) {
    if (fullySupportedLanguages.includes(lang)) {
        //console.log(`ok ${lang} is valid`);
        if (!stemmersCache[lang]) {
            switch (lang) {
                case 'en_US':
                    stemmersCache[lang] = new englishStemmer.EnglishStemmer();
                    break;
                case 'de_DE':
                    stemmersCache[lang] = new germanStemmer.GermanStemmer();
                    break;
                case 'fr_FR':
                    stemmersCache[lang] = new frenchStemmer.FrenchStemmer();
                    break;
                case 'it_IT':
                    stemmersCache[lang] = new italianStemmer.ItalianStemmer();
                    break;
            }
        }
        //console.log(`orig: ${word}, stemmed: ${stemmersCache[lang].stemWord(word)}`);
        return stemmersCache[lang].stemWord(word);
    }
    return word;
}
function getWordsWithPos(lang, words, identicals, debugHolder) {
    const identicalsMap = {};
    if (identicals) {
        // check type
        if (!Array.isArray(identicals)) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `identicals must be a string[][]`;
            throw err;
        }
        else {
            identicals.forEach(function (identicalList) {
                if (!Array.isArray(identicalList)) {
                    const err = new Error();
                    err.name = 'InvalidArgumentError';
                    err.message = `identicals must be a string[][]`;
                    throw err;
                }
            });
        }
        if (debugHolder) {
            debugHolder.identicals = identicals;
        }
        // do the job
        identicals.forEach(function (identicalList) {
            const mapTo = identicalList.join('_');
            identicalList.forEach(function (identicalElt) {
                identicalsMap[stemWordForLang(identicalElt, lang)] = mapTo;
            });
        });
    }
    if (debugHolder) {
        debugHolder.identicalsMap = identicalsMap;
    }
    const wordsWithPos = {};
    for (let j = 0; j < words.length; j++) {
        const word = identicalsMap[words[j]] || words[j];
        if (!wordsWithPos[word]) {
            wordsWithPos[word] = [];
        }
        wordsWithPos[word].push(j);
    }
    return wordsWithPos;
}
exports.getWordsWithPos = getWordsWithPos;
function getScore(wordsWithPos) {
    let score = 0;
    Object.keys(wordsWithPos).forEach(function (word) {
        const positions = wordsWithPos[word];
        for (let j = 1; j < positions.length; j++) {
            score += 1 / (positions[j] - positions[j - 1]);
        }
    });
    return score;
}
exports.getScore = getScore;
function getStemmedWords(text, stopwords, lang) {
    // console.log(`getStemmedWords: ${text}`);
    const res = extractWords(text, lang)
        .map(function (alt) {
        return alt.toLowerCase();
    })
        .filter(function (alt) {
        return !stopwords.includes(alt);
    })
        .map(elt => {
        return stemWordForLang(elt, lang);
    });
    // console.log(`getStemmedWords result: ${res}`);
    return res;
}
exports.getStemmedWords = getStemmedWords;
function scoreAlternative(lang, alternative, stopWordsToAdd, stopWordsToRemove, stopWordsOverride, identicals, debugHolder) {
    // console.log(stemmer.stemWord("baby"));
    // console.log(stopWordsToAdd);
    const stopwords = getStopWords(lang, stopWordsToAdd, stopWordsToRemove, stopWordsOverride);
    // console.log(stopwords);
    const filteredAlt = getStemmedWords(alternative, stopwords, lang);
    if (debugHolder) {
        debugHolder.filteredAlt = filteredAlt;
    }
    const wordsWithPos = getWordsWithPos(lang, filteredAlt, identicals, debugHolder);
    if (debugHolder) {
        // only keep ones with > 1 for readability
        debugHolder.wordsWithPos = {};
        Object.keys(wordsWithPos).forEach(function (word) {
            if (wordsWithPos[word].length > 1) {
                debugHolder.wordsWithPos[word] = wordsWithPos[word];
            }
        });
    }
    // console.log(wordsWithPos);
    // score
    const score = getScore(wordsWithPos);
    if (debugHolder) {
        debugHolder.score = score;
    }
    return score;
    // console.log(score);
}
exports.scoreAlternative = scoreAlternative;
function getBest(lang, alternatives, stopWordsToAdd, stopWordsToRemove, stopWordsOverride, identicals) {
    const scores = [];
    alternatives.forEach(function (alt) {
        scores.push(scoreAlternative(lang, alt, stopWordsToAdd, stopWordsToRemove, stopWordsOverride, identicals, null));
    });
    return scores.indexOf(Math.min(...scores));
}
exports.getBest = getBest;
//# sourceMappingURL=index.js.map