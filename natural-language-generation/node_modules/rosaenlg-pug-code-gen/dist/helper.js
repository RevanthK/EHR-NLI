"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// en_US
const english_verbs_irregular_1 = __importDefault(require("english-verbs-irregular"));
const english_verbs_gerunds_1 = __importDefault(require("english-verbs-gerunds"));
const englishVerbs = __importStar(require("english-verbs-helper"));
const english_plurals_list_1 = __importDefault(require("english-plurals-list"));
const englishPlurals = __importStar(require("english-plurals"));
// fr_fr
const frenchWordsGender = __importStar(require("french-words-gender"));
const french_words_gender_lefff_1 = __importDefault(require("french-words-gender-lefff"));
const frenchVerbs = __importStar(require("french-verbs"));
const french_verbs_lefff_1 = __importDefault(require("french-verbs-lefff"));
// de_DE
const germanWords = __importStar(require("german-words"));
const german_words_dict_1 = __importDefault(require("german-words-dict"));
const germanAdjectives = __importStar(require("german-adjectives"));
const german_adjectives_dict_1 = __importDefault(require("german-adjectives-dict"));
const germanVerbs = __importStar(require("german-verbs"));
const german_verbs_dict_1 = __importDefault(require("german-verbs-dict"));
// it_IT
const italianAdjectives = __importStar(require("italian-adjectives"));
const italian_adjectives_dict_1 = __importDefault(require("italian-adjectives-dict"));
const italianWords = __importStar(require("italian-words"));
const italian_words_dict_1 = __importDefault(require("italian-words-dict"));
const italianVerbs = __importStar(require("italian-verbs"));
const italian_verbs_dict_1 = __importDefault(require("italian-verbs-dict"));
const recast_1 = require("recast");
function keyEqualsTo(prop, val) {
    // when 'val':, is in value, when val:, is in name
    return prop.key.value === val || prop.key.name === val;
}
class CodeGenHelper {
    constructor(language, embedResources) {
        this.verbCandidates = [];
        this.wordCandidates = [];
        this.adjectiveCandidates = [];
        this.language = language;
        this.embedResources = embedResources;
        // create English combined resource
        if (this.language === 'en_US') {
            this.mergedVerbsDataEn = englishVerbs.mergeVerbsData(english_verbs_irregular_1.default, english_verbs_gerunds_1.default);
        }
    }
    // public for test purposes
    getVerbCandidates() {
        return this.verbCandidates;
    }
    getWordCandidates() {
        return this.wordCandidates;
    }
    getAdjectiveCandidates() {
        return this.adjectiveCandidates;
    }
    getAllLinguisticResources(explicitResources) {
        // 1. init
        let allLinguisticResources = {
            verbs: {},
            words: {},
            adjectives: {},
        };
        // 2. get explicit resources, already solved
        allLinguisticResources = Object.assign(Object.assign({}, allLinguisticResources), explicitResources);
        // 3. add found candidates
        // console.log(verbCandidates);
        allLinguisticResources.verbs = Object.assign(Object.assign({}, this.getVerbCandidatesData()), allLinguisticResources.verbs);
        allLinguisticResources.words = Object.assign(Object.assign({}, this.getWordCandidatesData()), allLinguisticResources.words);
        // console.log(wordCandidates);
        allLinguisticResources.adjectives = Object.assign(Object.assign({}, this.getAdjectiveCandidatesData()), allLinguisticResources.adjectives);
        return allLinguisticResources;
    }
    getVerbCandidatesData() {
        const res = {};
        // so that they are available in the forEach
        const language = this.language;
        const mergedVerbsDataEn = this.mergedVerbsDataEn;
        this.verbCandidates.forEach(function (verbCandidate) {
            switch (language) {
                case 'en_US': {
                    const irregularVerbInfo = englishVerbs.getVerbInfo(mergedVerbsDataEn, verbCandidate);
                    if (irregularVerbInfo) {
                        res[verbCandidate] = irregularVerbInfo;
                    }
                    // else we don't care: regular verbs are ok
                    break;
                }
                case 'fr_FR': {
                    try {
                        res[verbCandidate] = frenchVerbs.getVerbInfo(french_verbs_lefff_1.default, verbCandidate);
                    }
                    catch (e) {
                        console.log(`Could not find any data for fr_FR verb candidate ${verbCandidate}`);
                    }
                    break;
                }
                case 'de_DE': {
                    try {
                        res[verbCandidate] = germanVerbs.getVerbInfo(german_verbs_dict_1.default, verbCandidate);
                    }
                    catch (e) {
                        console.log(`Could not find any data for de_DE verb candidate ${verbCandidate}`);
                    }
                    break;
                }
                case 'it_IT': {
                    try {
                        res[verbCandidate] = italianVerbs.getVerbInfo(italian_verbs_dict_1.default, verbCandidate);
                    }
                    catch (e) {
                        console.log(`Could not find any data for it_IT verb candidate ${verbCandidate}`);
                    }
                    break;
                }
            }
        });
        return res;
    }
    getWordCandidatesData() {
        const res = {};
        const language = this.language;
        this.wordCandidates.forEach(function (wordCandidate) {
            switch (language) {
                case 'en_US': {
                    // we have more than just the irregular ones, but it's not a problem
                    res[wordCandidate] = englishPlurals.getPlural(english_plurals_list_1.default, wordCandidate);
                    break;
                }
                case 'fr_FR': {
                    try {
                        res[wordCandidate] = frenchWordsGender.getGenderFrenchWord(french_words_gender_lefff_1.default, wordCandidate);
                    }
                    catch (e) {
                        console.log(`Could not find any data for fr_FR word candidate ${wordCandidate}`);
                    }
                    break;
                }
                case 'de_DE': {
                    try {
                        res[wordCandidate] = germanWords.getWordInfo(german_words_dict_1.default, wordCandidate);
                    }
                    catch (e) {
                        console.log(`Could not find any data for de_DE word candidate ${wordCandidate}`);
                    }
                    break;
                }
                case 'it_IT': {
                    try {
                        res[wordCandidate] = italianWords.getWordInfo(italian_words_dict_1.default, wordCandidate);
                    }
                    catch (e) {
                        console.log(`Could not find any data for it_IT word candidate ${wordCandidate}`);
                    }
                    break;
                }
            }
        });
        return res;
    }
    getAdjectiveCandidatesData() {
        const res = {};
        const language = this.language;
        this.adjectiveCandidates.forEach(function (adjectiveCandidate) {
            switch (language) {
                case 'de_DE': {
                    try {
                        const adjData = germanAdjectives.getAdjectiveInfo(german_adjectives_dict_1.default, adjectiveCandidate);
                        res[adjectiveCandidate] = adjData;
                    }
                    catch (e) /* istanbul ignore next */ {
                        console.log(`Could not find any data for de_DE adjective candidate ${adjectiveCandidate}`);
                    }
                    break;
                }
                case 'it_IT': {
                    try {
                        const adjData = italianAdjectives.getAdjectiveInfo(italian_adjectives_dict_1.default, adjectiveCandidate);
                        res[adjectiveCandidate] = adjData;
                    }
                    catch (e) /* istanbul ignore next */ {
                        console.log(`Could not find any data for it_IT adjective candidate ${adjectiveCandidate}`);
                    }
                    break;
                }
            }
        });
        return res;
    }
    extractHelper(args, extractor, store) {
        const candidate = extractor.apply(this, [args]);
        if (candidate) {
            store.push(candidate);
        }
    }
    extractVerbCandidate(args) {
        this.extractHelper(args, this.getVerbCandidate, this.verbCandidates);
    }
    getVerbCandidate(args) {
        const languagesWithVerbsToExtract = ['en_US', 'fr_FR', 'de_DE', 'it_IT'];
        if (!this.embedResources || languagesWithVerbsToExtract.indexOf(this.language) === -1) {
            return null;
        }
        // console.log(`extractVerbCandidate called on <${args}>`);
        const parsed = recast_1.parse(args);
        // console.log("ooo " + JSON.stringify(parsed));
        const parsedExpr = parsed.program.body[0].expression;
        if (parsedExpr.expressions && parsedExpr.expressions.length > 1) {
            const secondArg = parsedExpr.expressions[1];
            // console.log("secondArg: " + JSON.stringify(secondArg));
            let found;
            if (secondArg.type === 'Literal') {
                // string second arg form
                found = secondArg.value;
                //console.log(`found string second arg form: ${found}`);
            }
            else {
                // "verb:"" form
                recast_1.visit(secondArg, {
                    visitProperty: function (path) {
                        if (keyEqualsTo(path.value, 'verb')) {
                            if (path.value.value.type === 'Literal') {
                                found = path.value.value.value;
                                //console.log(`found verb: form: ${found}`);
                                this.abort();
                            }
                        }
                        this.traverse(path);
                    },
                });
            }
            return found;
        }
    }
    extractWordCandidateFromSetRefGender(args) {
        this.extractHelper(args, this.getWordCandidateFromSetRefGender, this.wordCandidates);
    }
    getWordCandidateFromSetRefGender(args) {
        const languagesWithWordResources = ['de_DE', 'it_IT', 'fr_FR'];
        if (!this.embedResources || languagesWithWordResources.indexOf(this.language) === -1) {
            return;
        }
        // console.log(`getWordCandidateFromSetRefGender called on <${args}>`);
        const parsed = recast_1.parse(args);
        const parsedExpr = parsed.program.body[0].expression;
        //console.log(JSON.stringify(parsedExpr));
        if (parsedExpr.expressions && parsedExpr.expressions.length >= 1) {
            // console.log(parsedExpr.expressions);
            const secondArg = parsedExpr.expressions[1];
            // console.log("secondArg: " + JSON.stringify(secondArg));
            if (secondArg.type === 'Literal') {
                // string second arg form
                /*
                  - setRefGender(PRODUKT2, 'Gurke');
                  is ok, but avoid:
                  - setRefGender(PRODUKT, 'N');
                */
                if (secondArg.value !== 'M' && secondArg.value !== 'F' && secondArg.value !== 'N') {
                    return secondArg.value;
                }
            }
        }
    }
    extractAdjectiveCandidateFromAgreeAdj(args) {
        this.extractHelper(args, this.getAdjectiveCandidateFromAgreeAdj, this.adjectiveCandidates);
    }
    getAdjectiveCandidateFromAgreeAdj(args) {
        const languagesWithAdjResources = ['de_DE', 'it_IT', 'fr_FR'];
        if (!this.embedResources || languagesWithAdjResources.indexOf(this.language) === -1) {
            return;
        }
        // console.log(`getAdjectiveCandidateFromAgreeAdj called on <${args}>`);
        const parsed = recast_1.parse(args);
        const parsedExpr = parsed.program.body[0].expression;
        let firstArg;
        if (parsedExpr.expressions && parsedExpr.expressions.length >= 1) {
            // multiple args
            firstArg = parsedExpr.expressions[0];
        }
        else {
            // single argument
            firstArg = parsedExpr;
        }
        if (firstArg.type === 'Literal') {
            // second arg form must be string
            return firstArg.value;
        }
    }
    extractAdjectiveCandidateFromValue(args) {
        // cannot use extractHelper because returns a []
        const candidates = this.getAdjectiveCandidatesFromValue(args);
        this.adjectiveCandidates = this.adjectiveCandidates.concat(candidates);
    }
    getAdjectiveCandidatesFromValue(args) {
        const languagesWithAdjResourcesInValue = ['de_DE', 'it_IT', 'fr_FR'];
        if (!this.embedResources || languagesWithAdjResourcesInValue.indexOf(this.language) === -1) {
            return [];
        }
        const res = [];
        //console.log(`getAdjectiveCandidatesFromValue called on <${args}>`);
        const parsed = recast_1.parse(args);
        // console.log("ooo " + JSON.stringify(parsed));
        const parsedExpr = parsed.program.body[0].expression;
        if (parsedExpr.expressions && parsedExpr.expressions.length > 1) {
            const secondArg = parsedExpr.expressions[1];
            // console.log("secondArg: " + JSON.stringify(secondArg));
            function addArrayToRes(elts) {
                for (let i = 0; i < elts.length; i++) {
                    if (elts[i].type === 'Literal') {
                        res.push(elts[i].value);
                    }
                }
            }
            recast_1.visit(secondArg, {
                visitProperty: function (path) {
                    if (keyEqualsTo(path.value, 'adj')) {
                        const pvv = path.value.value;
                        if (pvv.type === 'Literal') {
                            res.push(pvv.value);
                        }
                        else if (pvv.type === 'ArrayExpression') {
                            const elts = pvv.elements;
                            addArrayToRes(elts);
                        }
                        else if (pvv.type === 'ObjectExpression') {
                            const props = pvv.properties;
                            for (let i = 0; i < props.length; i++) {
                                const prop = props[i];
                                if (keyEqualsTo(prop, 'BEFORE') || keyEqualsTo(prop, 'AFTER')) {
                                    addArrayToRes(prop.value.elements);
                                }
                            }
                        }
                    }
                    else if (keyEqualsTo(path.value, 'possessiveAdj')) {
                        // Italian possessiveAdj:
                        if (path.value.value.type === 'Literal') {
                            res.push(path.value.value.value);
                        }
                    }
                    this.traverse(path);
                },
            });
        }
        return res;
    }
    extractWordCandidateFromThirdPossession(args) {
        this.extractHelper(args, this.getWordCandidateFromThirdPossession, this.wordCandidates);
    }
    getWordCandidateFromThirdPossession(args) {
        // console.log(`getWordCandidateFromThirdPossession called on <${args}>`);
        const forLanguages = ['de_DE', 'fr_FR'];
        if (!this.embedResources || forLanguages.indexOf(this.language) === -1) {
            return;
        }
        // #[+thirdPossession(XXX, 'couleur')]
        const parsed = recast_1.parse(args);
        const parsedExpr = parsed.program.body[0].expression;
        if (parsedExpr.expressions && parsedExpr.expressions.length > 1) {
            // console.log(parsedExpr.expressions);
            const secondArg = parsedExpr.expressions[1];
            // console.log("secondArg: " + JSON.stringify(secondArg));
            if (secondArg.type === 'Literal') {
                // string second arg form
                return secondArg.value;
            }
        }
    }
    extractWordCandidateFromSubstantive(args) {
        this.extractHelper(args, this.getWordCandidateFromSubstantive, this.wordCandidates);
    }
    getWordCandidateFromSubstantive(args) {
        // console.log(`getWordCandidateFromSubstantive called on <${args}>`);
        const forLanguages = ['en_US'];
        if (!this.embedResources || forLanguages.indexOf(this.language) === -1) {
            return;
        }
        // #[+substantive("tomato", ...)]
        const parsed = recast_1.parse(args);
        const parsedExpr = parsed.program.body[0].expression;
        let firstArg;
        if (parsedExpr.expressions && parsedExpr.expressions.length >= 1) {
            // multiple args
            firstArg = parsedExpr.expressions[0];
            if (firstArg.type === 'Literal') {
                // second arg form must be string
                return firstArg.value;
            }
        }
    }
    extractWordCandidateFromValue(args) {
        this.extractHelper(args, this.getWordCandidateFromValue, this.wordCandidates);
    }
    getWordCandidateFromValue(args) {
        const forLanguages = ['de_DE', 'fr_FR', 'it_IT'];
        if (!this.embedResources || forLanguages.indexOf(this.language) === -1) {
            return;
        }
        //console.log(`extractWordCandidateFromValue called on <${args}>`);
        /*
        no: it is also useful when adj is here, to make the agreement!
        if (args.indexOf('represents') === -1) {
          return null;
        }
        */
        const parsed = recast_1.parse(args);
        const parsedExpr = parsed.program.body[0].expression;
        let firstArg;
        if (parsedExpr.expressions && parsedExpr.expressions.length >= 1) {
            // multiple args
            firstArg = parsedExpr.expressions[0];
        }
        else {
            // single argument
            firstArg = parsedExpr;
        }
        if (firstArg.type === 'Literal') {
            // second arg form must be string
            return firstArg.value;
        }
    }
}
exports.CodeGenHelper = CodeGenHelper;
//# sourceMappingURL=helper.js.map