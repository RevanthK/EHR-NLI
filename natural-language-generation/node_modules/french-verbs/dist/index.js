"use strict";
/*

8 temps de l'indicatif :
  Présent
  Passé composé
  Imparfait
  Plus-que-parfait
  Passé simple
  Passé antérieur
  Futur simple
  Futur antérieur

4 temps du subjonctif :
  Présent
  Passé
  Imparfait
  Plus-que-parfait

3 temps du conditionnel :
  Présent
  Passé 1ère forme
  Passé 2ème forme

2 temps de l'impératif :
  Présent
  Passé

2 temps du participe :
  Présent
  Passé

2 temps de l'infinitif :
  Présent
  Passé

2 temps du gérondif :
  Présent
  Passé
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const french_h_muet_aspire_1 = require("french-h-muet-aspire");
const conjAvoir = {
    P: ['ai', 'as', 'a', 'avons', 'avez', 'ont'],
    S: ['aie', 'aies', 'ait', 'ayons', 'ayez', 'aient'],
    Y: ['NA', 'aie', 'NA', 'ayons', 'ayez', 'NA'],
    F: ['aurai', 'auras', 'aura', 'aurons', 'aurez', 'auront'],
    C: ['aurais', 'aurais', 'aurait', 'aurions', 'auriez', 'auraient'],
    I: ['avais', 'avais', 'avait', 'avions', 'aviez', 'avaient'],
    W: ['avoir'],
    G: ['ayant'],
    K: ['eu', 'eus', 'eue', 'eues'],
    J: ['eus', 'eus', 'eut', 'eûmes', 'eûtes', 'eurent'],
    T: ['eusse', 'eusses', 'eût', 'eussions', 'eussiez', 'eussent'],
};
const conjEtre = {
    P: ['suis', 'es', 'est', 'sommes', 'êtes', 'sont'],
    J: ['fus', 'fus', 'fut', 'fûmes', 'fûtes', 'furent'],
    T: ['fusse', 'fusses', 'fût', 'fussions', 'fussiez', 'fussent'],
    F: ['serai', 'seras', 'sera', 'serons', 'serez', 'seront'],
    C: ['serais', 'serais', 'serait', 'serions', 'seriez', 'seraient'],
    S: ['sois', 'sois', 'soit', 'soyons', 'soyez', 'soient'],
    Y: ['NA', 'sois', 'NA', 'soyons', 'soyez', 'NA'],
    I: ['étais', 'étais', 'était', 'étions', 'étiez', 'étaient'],
    G: ['étant'],
    K: ['été', 'été', 'été', 'été'],
    W: ['être'],
};
function getVerbInfo(verbsInfo, verb) {
    if (verb === 'avoir')
        return conjAvoir;
    if (verb === 'être')
        return conjEtre;
    if (!verbsInfo) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = 'verbs list must not be null';
        throw err;
    }
    const verbInfo = verbsInfo[verb];
    if (!verbInfo) {
        const err = new Error();
        err.name = 'NotFoundInDict';
        err.message = `${verb} not in dict`;
        throw err;
    }
    return verbInfo;
}
exports.getVerbInfo = getVerbInfo;
// is required at runtime (not only comp)
const listEtre = [
    'aller',
    'apparaître',
    'arriver',
    'débeller',
    'décéder',
    'devenir',
    'échoir',
    'entrer',
    'intervenir',
    'mourir',
    'naitre',
    'naître',
    'partir',
    'parvenir',
    'provenir',
    'redevenir',
    'repartir',
    'rester',
    'resurvenir',
    'retomber',
    'revenir',
    'survenir',
    'tomber',
    'venir',
];
function alwaysAuxEtre(verb) {
    return listEtre.indexOf(verb) > -1;
}
exports.alwaysAuxEtre = alwaysAuxEtre;
const french_verbs_transitive_1 = __importDefault(require("french-verbs-transitive"));
function isTransitive(verb) {
    return french_verbs_transitive_1.default.indexOf(verb) > -1;
}
exports.isTransitive = isTransitive;
function getConjugation(verbsList, verb, tense, person, aux, agreeGender, agreeNumber, pronominal) {
    if (!verb) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = 'verb must not be null';
        throw err;
    }
    if (person == null) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = 'person must not be null';
        throw err;
    }
    const validTenses = [
        'PRESENT',
        'FUTUR',
        'IMPARFAIT',
        'PASSE_SIMPLE',
        'CONDITIONNEL_PRESENT',
        'IMPERATIF_PRESENT',
        'SUBJONCTIF_PRESENT',
        'SUBJONCTIF_IMPARFAIT',
        'PASSE_COMPOSE',
        'PLUS_QUE_PARFAIT',
    ];
    if (!tense || validTenses.indexOf(tense) === -1) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = `tense must be ${validTenses.join()}`;
        throw err;
    }
    if (!agreeGender) {
        agreeGender = 'M';
    }
    if (!agreeNumber) {
        agreeNumber = 'S';
    }
    // s'écrier, se rendre...
    if (verb.startsWith('se ')) {
        pronominal = true;
        verb = verb.replace(/^se\s+/, '');
    }
    else if (verb.startsWith("s'")) {
        pronominal = true;
        verb = verb.replace(/^s'\s*/, '');
    }
    const verbInfo = getVerbInfo(verbsList, verb);
    // debug( JSON.stringify(verbInfo) );
    const tenseMapping = {
        PRESENT: 'P',
        FUTUR: 'F',
        IMPARFAIT: 'I',
        PASSE_SIMPLE: 'J',
        CONDITIONNEL_PRESENT: 'C',
        IMPERATIF_PRESENT: 'Y',
        SUBJONCTIF_PRESENT: 'S',
        SUBJONCTIF_IMPARFAIT: 'T',
    };
    let conjugated;
    if (tense === 'PASSE_COMPOSE' || tense === 'PLUS_QUE_PARFAIT') {
        if (!aux) {
            if (pronominal) {
                aux = 'ETRE';
            }
            else if (alwaysAuxEtre(verb)) {
                aux = 'ETRE';
            }
            else if (isTransitive(verb)) {
                aux = 'AVOIR'; // rather AVOIR if not specified
            }
            else {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = `aux property must be set with ${tense} for ${verb}`;
                throw err;
            }
        }
        else if (aux != 'AVOIR' && aux != 'ETRE') {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `aux must be AVOIR or ETRE`;
            throw err;
        }
        const tempsAux = tense === 'PASSE_COMPOSE' ? 'P' : 'I'; // présent ou imparfait
        const conjugatedAux = getVerbInfo(null, aux === 'AVOIR' ? 'avoir' : 'être')[tempsAux][person];
        const participePasseList = verbInfo['K'];
        if (!participePasseList) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `no participe passé for ${verb}`;
            throw err;
        }
        const mappingGenderNumber = { MS: 0, MP: 1, FS: 2, FP: 3 };
        const indexGenderNumber = mappingGenderNumber[agreeGender + agreeNumber];
        const participePasse = participePasseList[indexGenderNumber];
        // debug(`${agreeGender+agreeNumber} ${indexGenderNumber}`);
        /* istanbul ignore if */
        if (!participePasse) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `no participe passé form for ${verb}`;
            throw err;
        }
        conjugated = `${conjugatedAux} ${participePasse}`;
    }
    else {
        const indexTemps = tenseMapping[tense];
        const tenseInLib = verbInfo[indexTemps];
        if (!tenseInLib) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `${tense} tense not available in French for ${verb}`;
            throw err;
        }
        const formInLib = tenseInLib[person];
        if (!formInLib || formInLib === 'NA') {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `person ${person} not available in French for ${verb} in ${tense}`;
            throw err;
        }
        conjugated = formInLib;
    }
    if (pronominal) {
        const pronominalMapping = ['me', 'te', 'se', 'nous', 'vous', 'se'];
        let contract = false;
        if ([0, 1, 2, 5].indexOf(person) > -1) {
            // potential contraction
            const voyelles = 'aeiouyàáâãäåèéêëìíîïòóôõöøùúûüÿAEIOUYÀÁÂÃÄÅÈÉÊËÌÍÎÏÒÓÔÕÖØÙÚÛÜŸ'; // toutesVoyellesMinMaj
            const startsWithVoyelle = RegExp(`^[${voyelles}]`);
            if (startsWithVoyelle.test(conjugated)) {
                contract = true;
            }
            else if (conjugated.startsWith('h') && !french_h_muet_aspire_1.isHAspire(verb)) {
                // take infinitive, not conjugated form
                contract = true;
            }
        }
        if (contract) {
            return `${pronominalMapping[person].substring(0, 1)}'${conjugated}`;
        }
        else {
            return `${pronominalMapping[person]} ${conjugated}`;
        }
    }
    else {
        return conjugated;
    }
}
exports.getConjugation = getConjugation;
//# sourceMappingURL=index.js.map