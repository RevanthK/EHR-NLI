"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const french_words_gender_1 = require("french-words-gender");
const french_words_gender_lefff_1 = __importDefault(require("french-words-gender-lefff"));
const german_words_1 = require("german-words");
const german_words_dict_1 = __importDefault(require("german-words-dict"));
const italian_words_1 = require("italian-words");
const italian_words_dict_1 = __importDefault(require("italian-words-dict"));
class GenderNumberManager {
    constructor(language) {
        this.refNumberMap = new Map();
        this.refGenderMap = new Map();
        this.language = language;
    }
    setEmbeddedWords(embeddedWords) {
        this.embeddedWords = embeddedWords;
    }
    getRefGenderMap() {
        return this.refGenderMap;
    }
    setRefGenderMap(refGenderMap) {
        this.refGenderMap = refGenderMap;
    }
    getRefNumberMap() {
        return this.refNumberMap;
    }
    setRefNumberMap(refNumberMap) {
        this.refNumberMap = refNumberMap;
    }
    /*
    public setSpy(spy: Spy): void {
      this.spy = spy;
    }
    */
    isEmptyObj(obj) {
        if (!obj)
            return true;
        return Object.keys(obj).length === 0 && obj.constructor === Object;
    }
    setRefGenderNumber(obj, gender, number) {
        if (this.isEmptyObj(obj)) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = 'setRefGenderNumber obj should not be empty';
            throw err;
        }
        // dumpRefMap();
        if (gender) {
            this.setRefGender(obj, gender, null);
        }
        if (number) {
            this.setRefNumber(obj, number);
        }
        // debug(`just called setRefGenderNumber on ${JSON.stringify(obj)} ${gender} ${number}`);
        // dumpRefMap();
    }
    setRefGender(obj, genderOrWord, params) {
        //console.log(`setRefGenderNumber ${obj} ${genderOrWord}`);
        if (this.isEmptyObj(obj)) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = 'setRefGender obj should not be empty';
            throw err;
        }
        // dumpRefMap();
        // debug('setRefGender: ' + JSON.stringify(obj).substring(0, 20) + ' => ' + genderOrWord);
        let explicitGender;
        if (params && params.gender) {
            explicitGender = params.gender;
        }
        if (['M', 'F', 'N'].indexOf(genderOrWord) > -1) {
            explicitGender = genderOrWord;
        }
        if (explicitGender) {
            switch (this.language) {
                case 'fr_FR': {
                    if (explicitGender != 'M' && explicitGender != 'F') {
                        const err = new Error();
                        err.name = 'InvalidArgumentError';
                        err.message = `gender must be M or F in French, here is ${explicitGender}`;
                        throw err;
                    }
                    this.refGenderMap.set(obj, explicitGender);
                    return;
                }
                case 'de_DE': {
                    /* istanbul ignore if */
                    if (explicitGender != 'M' && explicitGender != 'F' && explicitGender != 'N') {
                        const err = new Error();
                        err.name = 'InvalidArgumentError';
                        err.message = `gender must be M or F or N in German, here is ${explicitGender}`;
                        throw err;
                    }
                    this.refGenderMap.set(obj, explicitGender);
                    return;
                }
                case 'it_IT': {
                    /* istanbul ignore if */
                    if (explicitGender != 'M' && explicitGender != 'F') {
                        const err = new Error();
                        err.name = 'InvalidArgumentError';
                        err.message = `gender must be M or F in Italian, here is ${explicitGender}`;
                        throw err;
                    }
                    this.refGenderMap.set(obj, explicitGender);
                    return;
                }
                case 'en_US': {
                    /* istanbul ignore if */
                    if (explicitGender != 'M' && explicitGender != 'F' && explicitGender != 'N') {
                        const err = new Error();
                        err.name = 'InvalidArgumentError';
                        err.message = `gender must be M or F or N in English, here is ${explicitGender}`;
                        throw err;
                    }
                    this.refGenderMap.set(obj, explicitGender);
                    return;
                }
                default: {
                    this.refGenderMap.set(obj, explicitGender);
                    return;
                }
            }
        }
        else if (genderOrWord) {
            // is a word
            switch (this.language) {
                case 'fr_FR': {
                    const genderFromFrDict = french_words_gender_1.getGenderFrenchWord(this.embeddedWords || french_words_gender_lefff_1.default, genderOrWord);
                    this.refGenderMap.set(obj, genderFromFrDict);
                    return;
                }
                case 'de_DE': {
                    const genderFromDeDict = german_words_1.getGenderGermanWord(this.embeddedWords || german_words_dict_1.default, genderOrWord);
                    this.refGenderMap.set(obj, genderFromDeDict);
                    return;
                }
                case 'it_IT': {
                    const genderFromItDict = italian_words_1.getGenderItalianWord(this.embeddedWords || italian_words_dict_1.default, genderOrWord);
                    this.refGenderMap.set(obj, genderFromItDict);
                    return;
                }
                case 'en_US':
                default:
                    const err = new Error();
                    err.name = 'InvalidArgumentError';
                    err.message = `there is no gender dict for ${this.language}, set gender directly`;
                    throw err;
            }
        }
        else {
            // called with null for instance
            // do nothing
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `setRefGender called on ${JSON.stringify(obj)} with invalid genderOrWord ${genderOrWord}`;
            throw err;
        }
        // dumpRefMap();
    }
    getRefGender(obj, params) {
        // debug('getRefGender called on: ' + JSON.stringify(obj));
        const inMainMap = this.refGenderMap.get(obj);
        if (inMainMap) {
            return inMainMap;
        }
        else if (typeof obj === 'string') {
            if (params) {
                if (params.gender) {
                    return params.gender;
                }
                if (this.language === 'de_DE' && params.genderOwned) {
                    return params.genderOwned;
                }
            }
            // debug("trying to find in dict: " + obj);
            switch (this.language) {
                case 'fr_FR':
                    return french_words_gender_1.getGenderFrenchWord(this.embeddedWords || french_words_gender_lefff_1.default, obj);
                case 'de_DE':
                    // debug(`will search in dict: ${obj}`);
                    return german_words_1.getGenderGermanWord(this.embeddedWords || german_words_dict_1.default, obj);
                case 'it_IT':
                    return italian_words_1.getGenderItalianWord(this.embeddedWords || italian_words_dict_1.default, obj);
            }
        }
        return null;
    }
    getAnonymous(gender, number) {
        // debug("getAnonymous");
        const obj = { isAnonymous: true };
        this.setRefGenderNumber(obj, gender, number);
        return obj;
    }
    getAnonMS() {
        return this.getAnonymous('M', 'S');
    }
    getAnonMP() {
        return this.getAnonymous('M', 'P');
    }
    getAnonFS() {
        return this.getAnonymous('F', 'S');
    }
    getAnonFP() {
        return this.getAnonymous('F', 'P');
    }
    getRefNumber(obj, params) {
        if (params) {
            // istanbul ignore else
            if (params.numberOwned) {
                return params.numberOwned;
            }
            else if (params.number) {
                return params.number;
            }
        }
        return this.refNumberMap.get(obj);
    }
    setRefNumber(obj, number) {
        if (this.isEmptyObj(obj)) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = 'setRefNumber obj should not be empty';
            throw err;
        }
        if (number != 'S' && number != 'P') {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `number must be S or P! - here is ${number}`;
            throw err;
        }
        // dumpRefMap();
        this.refNumberMap.set(obj, number);
        // dumpRefMap();
    }
}
exports.GenderNumberManager = GenderNumberManager;
//# sourceMappingURL=GenderNumberManager.js.map