"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const german_ordinals_1 = require("german-ordinals");
const french_ordinals_1 = require("french-ordinals");
const italian_ordinals_cardinals_1 = require("italian-ordinals-cardinals");
const Determiner_1 = require("./Determiner");
const french_grammar_js_1 = require("../dist/french-grammar.js");
const german_grammar_js_1 = require("../dist/german-grammar.js");
const english_grammar_js_1 = require("../dist/english-grammar.js");
const italian_grammar_js_1 = require("../dist/italian-grammar.js");
const n2words_1 = __importDefault(require("n2words"));
const EnglishOrdinals_1 = require("./EnglishOrdinals");
const numeral_1 = __importDefault(require("numeral"));
require("numeral/locales/de");
require("numeral/locales/fr");
require("numeral/locales/it");
const moment_1 = __importDefault(require("moment"));
require("moment/locale/fr");
require("moment/locale/de");
require("moment/locale/it");
class ValueManager {
    constructor(language, refsManager, genderNumberManager, randomManager, adjectiveManager, substantiveManager, helper, possessiveManager, dictHelper, asmManager) {
        this.simplifiedStringsCache = [];
        this.language = language;
        this.refsManager = refsManager;
        this.genderNumberManager = genderNumberManager;
        this.randomManager = randomManager;
        this.adjectiveManager = adjectiveManager;
        this.substantiveManager = substantiveManager;
        this.helper = helper;
        this.possessiveManager = possessiveManager;
        this.dictHelper = dictHelper;
        this.asmManager = asmManager;
    }
    setSpy(spy) {
        this.spy = spy;
    }
    value(obj, params) {
        // params is string when date
        if (typeof obj === 'string' && obj.charAt(0) === '<' && obj.charAt(obj.length - 1) === '>') {
            this.valueSimplifiedString(obj.substring(1, obj.length - 1), params);
            return; // don't do the rest, as it will call value again indirectly
        }
        if (params && params.owner) {
            const newParams = Object.assign({}, params);
            newParams.owner = null; // to avoid looping: we already take into account that param
            this.possessiveManager.thirdPossession(params.owner, obj, newParams);
            return;
        }
        if (typeof obj === 'number') {
            this.spy.appendPugHtml(this.valueNumber(obj, params));
        }
        else if (typeof obj === 'string') {
            this.spy.appendPugHtml(this.valueString(obj, params));
        }
        else if (obj instanceof Date) {
            this.spy.appendPugHtml(this.valueDate(obj, params ? params.dateFormat : null));
        }
        else if (obj.isAnonymous) {
            // do nothing
        }
        else if (typeof obj === 'object') {
            // it calls mixins, it already appends
            this.valueObject(obj, params);
        }
        else {
            const err = new Error();
            err.name = 'TypeError';
            err.message = `value not possible on: ${JSON.stringify(obj)}`;
            throw err;
        }
        if (params && params.represents) {
            this.genderNumberManager.setRefGender(params.represents, obj, params);
            // we cannot use setRefGenderNumber because sometimes obj is a word => dict lookup
            if (params.number) {
                this.genderNumberManager.setRefNumber(params.represents, params.number);
            }
        }
    }
    getLangForMoment() {
        if (['fr_FR', 'en_US', 'de_DE', 'it_IT'].indexOf(this.language) > -1) {
            return this.language.replace('_', '-');
        }
        else {
            return null;
        }
    }
    valueDate(val, dateFormat) {
        //console.log(`FORMAT: ${dateFormat}`);
        if (this.spy.isEvaluatingEmpty()) {
            return 'SOME_DATE';
        }
        else {
            if (this.getLangForMoment()) {
                const localLocale = moment_1.default(val);
                localLocale.locale(this.getLangForMoment());
                return this.helper.protectString(localLocale.format(dateFormat));
            }
            else {
                // default when other language
                const localLocale = moment_1.default(val);
                localLocale.locale('en-US');
                return this.helper.protectString(localLocale.format('YYYY-MM-DD'));
            }
        }
    }
    valueSimplifiedString(val, params) {
        if (this.spy.isEvaluatingEmpty()) {
            this.spy.appendPugHtml('SOME_STRING');
            return;
        }
        const supportedLanguages = ['fr_FR', 'de_DE', 'en_US', 'it_IT'];
        /* istanbul ignore if */
        if (supportedLanguages.indexOf(this.language) === -1) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `<...> syntax not implemented in ${this.language}`;
            throw err;
        }
        let solved;
        solved = this.simplifiedStringsCache[val];
        if (!solved) {
            // debug(`BEFORE: #${val}#`);
            try {
                switch (this.language) {
                    case 'fr_FR': {
                        solved = french_grammar_js_1.parse(val, { dictHelper: this.dictHelper });
                        break;
                    }
                    case 'de_DE': {
                        solved = german_grammar_js_1.parse(val, { dictHelper: this.dictHelper });
                        break;
                    }
                    case 'it_IT': {
                        solved = italian_grammar_js_1.parse(val, { dictHelper: this.dictHelper });
                        break;
                    }
                    case 'en_US': {
                        solved = english_grammar_js_1.parse(val, {
                        /* no dict */
                        });
                        break;
                    }
                }
                // debug(solved);
                // manager unknown words
                if (solved.unknownNoun) {
                    if (solved.gender != 'M' && solved.gender != 'F' && solved.gender != 'N') {
                        const err = new Error();
                        err.name = 'NotFoundInDict';
                        err.message = `${solved.noun} is not in dict. Indicate a gender, M F or N!`;
                        throw err;
                    }
                    delete solved['unknownNoun'];
                }
                this.simplifiedStringsCache[val] = solved;
            }
            catch (e) {
                const err = new Error();
                err.name = 'ParseError';
                err.message = `could not parse <${val}>: ${e.message}`;
                throw err;
            }
        }
        // we keep the params
        const newParams = Object.assign({}, solved, params);
        delete newParams['noun'];
        if (params && params.debug) {
            console.log(`DEBUG: <${val}> => ${JSON.stringify(solved)} - final: ${solved.noun} ${JSON.stringify(newParams)}`);
        }
        this.value(solved.noun, newParams);
    }
    valueString(val, params) {
        if (this.spy.isEvaluatingEmpty()) {
            return 'SOME_STRING';
        }
        // simplest case but edge case
        if (!params) {
            return val;
        }
        if (this.language === 'de_DE') {
            params.case = params.case || 'NOMINATIVE';
        }
        if (params.possessiveAdj && this.language != 'it_IT') {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = 'possessiveAdj param is only valid in it_IT';
            throw err;
        }
        // to check depending on language
        params.genderOwned = this.genderNumberManager.getRefGender(val, params);
        // if number is set, by default it is for the owneD thing, not the ownerR
        params.numberOwned = params.numberOwned || params.number || 'S';
        // debug(`here for ${val} with params: ${JSON.stringify(params)}`);
        let det = '';
        if (params && params.det) {
            det = Determiner_1.getDet(this.language, params.det, params); // can return ''
        }
        const getAdjStringFromList = (adjectives) => {
            if (!adjectives || adjectives.length === 0) {
                return '';
            }
            const agreedAdjs = [];
            for (let i = 0; i < adjectives.length; i++) {
                agreedAdjs.push(this.adjectiveManager.getAgreeAdj(adjectives[i], val, params));
            }
            const lastSep = agreedAdjs.length > 1 ? '¤' + this.asmManager.getDefaultLastSeparator() + '¤' : null;
            switch (agreedAdjs.length) {
                case 1:
                    return agreedAdjs[0];
                case 2:
                    return agreedAdjs.join(lastSep);
                default:
                    return agreedAdjs.slice(0, agreedAdjs.length - 1).join(', ') + lastSep + agreedAdjs[agreedAdjs.length - 1];
            }
        };
        let adjPos;
        if (params && params.adjPos) {
            adjPos = params.adjPos;
            if (adjPos && adjPos != 'AFTER' && adjPos != 'BEFORE') {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = 'adjective position must be either AFTER or BEFORE';
                throw err;
            }
        }
        if (!adjPos) {
            const defaultAdjPos = {
                // French: In general, and unlike English, French adjectives are placed after the noun they describe
                // eslint-disable-next-line @typescript-eslint/camelcase
                fr_FR: 'AFTER',
                // Italian l'adjectif qualificatif se place généralement après le nom mais peut également le précéder
                // eslint-disable-next-line @typescript-eslint/camelcase
                it_IT: 'AFTER',
                // eslint-disable-next-line @typescript-eslint/camelcase
                en_US: 'BEFORE',
                // eslint-disable-next-line @typescript-eslint/camelcase
                de_DE: 'BEFORE',
            };
            adjPos = defaultAdjPos[this.language];
        }
        let adjBefore = '';
        let adjAfter = '';
        {
            let adj = null; // used when not BEFORE + AFTER combined
            if (params && params.adj) {
                if (typeof params.adj === 'string' || params.adj instanceof String) {
                    adj = getAdjStringFromList([params.adj]);
                }
                else if (Array.isArray(params.adj)) {
                    adj = getAdjStringFromList(params.adj);
                }
                else if (typeof params.adj === 'object') {
                    if (!params.adj['BEFORE'] && !params.adj['AFTER']) {
                        const err = new Error();
                        err.name = 'InvalidArgumentError';
                        err.message = 'adj param has an invalid structure: is an object but no BEFORE or AFTER key';
                        throw err;
                    }
                    adjBefore = getAdjStringFromList(params.adj['BEFORE']);
                    adjAfter = getAdjStringFromList(params.adj['AFTER']);
                }
                else {
                    const err = new Error();
                    err.name = 'InvalidArgumentError';
                    err.message = 'adj param has an invalid structure';
                    throw err;
                }
                if (adj) {
                    switch (adjPos) {
                        case 'BEFORE': {
                            adjBefore = adj;
                            break;
                        }
                        case 'AFTER': {
                            adjAfter = adj;
                            break;
                        }
                    }
                }
            }
        }
        const valSubst = this.substantiveManager.getSubstantive(val, null, params);
        switch (this.language) {
            case 'en_US': {
                return `${det} ${adjBefore} ${valSubst} ${adjAfter}`;
            }
            case 'de_DE': {
                return `${det} ${adjBefore} ${valSubst} ${adjAfter}`;
            }
            case 'it_IT': {
                let possessiveAdj = '';
                if (params.possessiveAdj) {
                    possessiveAdj = this.adjectiveManager.getAgreeAdj(params.possessiveAdj, val, params);
                }
                if (adjBefore.endsWith("'")) {
                    // bell'uomo
                    return `${det} ${possessiveAdj} ${adjBefore}${valSubst} ${adjAfter}`;
                }
                else {
                    return `${det} ${possessiveAdj} ${adjBefore} ${valSubst} ${adjAfter}`;
                }
            }
            case 'fr_FR': {
                // in French, the potential change of the adj based on its position (vieux => vieil) is already done
                return `${det} ${adjBefore} ${valSubst} ${adjAfter}`;
            }
            default: {
                return `${det} ${adjBefore} ${valSubst} ${adjAfter}`;
            }
        }
    }
    valueObject(obj, params) {
        // debug(obj);
        //- we already have the next one
        if (this.refsManager.getNextRef(obj)) {
            // debug('we already have the next one');
            this.randomManager.setRndNextPos(this.refsManager.getNextRef(obj).rndNextPos);
            this.refsManager.deleteNextRef(obj);
        }
        if (params && params.REPRESENTANT === 'ref') {
            this.valueRef(obj, params);
        }
        else if (params && params.REPRESENTANT === 'refexpr') {
            this.valueRefexpr(obj, params);
        }
        else if (!this.refsManager.hasTriggeredRef(obj)) {
            this.valueRef(obj, params);
        }
        else if (obj.refexpr) {
            this.valueRefexpr(obj, params);
        }
        else {
            //- we trigger ref if obj has no refexpr
            this.valueRef(obj, params);
        }
    }
    valueRefexpr(obj, params) {
        // debug('refexpr: ' + JSON.stringify(params));
        // is only called when obj.refexpr has a value
        this.spy.getPugMixins()[obj.refexpr](obj, params);
    }
    valueRef(obj, params) {
        //- printObj('value_ref', obj)
        if (obj.ref) {
            // debug('value_ref_ok: ' + obj.ref);
            this.spy.getPugMixins()[obj.ref](obj, params);
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `${JSON.stringify(obj)} has no ref mixin`;
            throw err;
        }
        this.refsManager.setTriggeredRef(obj);
    }
    getLangForNumeral() {
        if (['fr_FR', 'en_US', 'de_DE', 'it_IT'].indexOf(this.language) > -1) {
            return this.language.split('_')[0];
        }
        else {
            return null;
        }
    }
    valueNumberTextualFloatPart(floatPartString) {
        const numberTable = {
            // eslint-disable-next-line @typescript-eslint/camelcase
            en_US: ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'],
            // eslint-disable-next-line @typescript-eslint/camelcase
            fr_FR: ['zéro', 'un', 'deux', 'trois', 'quatre', 'cinq', 'six', 'sept', 'huit', 'neuf'],
            // eslint-disable-next-line @typescript-eslint/camelcase
            it_IT: ['zero', 'uno', 'due', 'tre', 'quattro', 'cinque', 'sei', 'sette', 'otto', 'nove'],
            // eslint-disable-next-line @typescript-eslint/camelcase
            de_DE: ['null', 'eins', 'zwei', 'drei', 'vier', 'fünf', 'sechs', 'sieben', 'acht', 'neun'],
        };
        const resArr = [];
        for (let i = 0; i < floatPartString.length; i++) {
            resArr.push(numberTable[this.language][Number(floatPartString.charAt(i))]);
        }
        return resArr.join(' ');
    }
    valueNumberTextual(val) {
        const languagesWithTextual = ['fr_FR', 'de_DE', 'en_US', 'it_IT'];
        if (languagesWithTextual.indexOf(this.language) == -1) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `TEXTUAL not available in ${this.language}`;
            throw err;
        }
        // eslint-disable-next-line @typescript-eslint/camelcase
        const langMap = { fr_FR: 'fr', en_US: 'en', it_IT: 'it', de_DE: 'de' };
        // eslint-disable-next-line @typescript-eslint/camelcase
        const sepMap = { fr_FR: 'virgule', en_US: 'point', it_IT: 'punto', de_DE: 'Komma' };
        let res = '';
        if (val % 1 === 0) {
            // is int
            res = n2words_1.default(val, { lang: langMap[this.language] });
        }
        else {
            // is float
            const splitVal = (val + '').split('.');
            res =
                n2words_1.default(splitVal[0], { lang: langMap[this.language] }) +
                    ' ' +
                    sepMap[this.language] +
                    ' ' +
                    this.valueNumberTextualFloatPart(splitVal[1]);
        }
        return res;
    }
    valueNumber(val, params) {
        if (this.spy.isEvaluatingEmpty()) {
            return 'SOME_NUMBER';
        }
        else {
            if (params && params.AS_IS) {
                return this.helper.protectString(val.toString());
            }
            else if (params && params.FORMAT) {
                const format = params.FORMAT;
                if (this.getLangForNumeral()) {
                    numeral_1.default.locale(this.getLangForNumeral());
                    return this.helper.protectString(numeral_1.default(val).format(format));
                }
                else {
                    const err = new Error();
                    err.name = 'InvalidArgumentError';
                    err.message = `FORMAT not available in ${this.language}`;
                    throw err;
                }
            }
            else if (params && params.TEXTUAL) {
                return this.valueNumberTextual(val);
            }
            else if (params && params.ORDINAL_NUMBER) {
                if (this.getLangForNumeral()) {
                    numeral_1.default.locale(this.getLangForNumeral());
                    return this.helper.protectString(numeral_1.default(val).format('o'));
                }
                else {
                    const err = new Error();
                    err.name = 'InvalidArgumentError';
                    err.message = `ORDINAL_NUMBER not available in ${this.language}`;
                    throw err;
                }
            }
            else if (params && params.ORDINAL_TEXTUAL) {
                if (val % 1 != 0) {
                    // is not int
                    const err = new Error();
                    err.name = 'InvalidArgumentError';
                    err.message = `ORDINAL_TEXTUAL must be an integer, here ${val}`;
                    throw err;
                }
                switch (this.language) {
                    case 'en_US':
                        return EnglishOrdinals_1.makeOrdinal(n2words_1.default(val, { lang: 'en' }));
                    case 'fr_FR':
                        return french_ordinals_1.getOrdinal(val);
                    case 'de_DE':
                        return german_ordinals_1.getOrdinal(val);
                    case 'it_IT': {
                        const gender = params.agree != null ? this.genderNumberManager.getRefGender(params.agree, params) : 'M';
                        return italian_ordinals_cardinals_1.getOrdinal(val, gender);
                    }
                    default: {
                        const err = new Error();
                        err.name = 'InvalidArgumentError';
                        err.message = `ORDINAL_TEXTUAL not available in ${this.language}`;
                        throw err;
                    }
                }
            }
            else {
                if (this.getLangForNumeral()) {
                    numeral_1.default.locale(this.getLangForNumeral());
                    return this.helper.protectString(numeral_1.default(val).format('0,0.[000000000000]'));
                }
                else {
                    return this.helper.protectString(val.toString());
                }
            }
        }
    }
}
exports.ValueManager = ValueManager;
//# sourceMappingURL=ValueManager.js.map