"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rosaenlg_packager_1 = require("rosaenlg-packager");
const RenderOptions_1 = require("./RenderOptions");
const crypto_1 = require("crypto");
class RosaeContext {
    /*
      rosaeNlgFeatures can be null, for instance when used on get on Lambda: we don't need to be able to compile
    */
    constructor(packagedTemplateWithUserAsParam, rosaeNlgFeatures) {
        // make a copy
        this.packagedTemplateWithUser = JSON.parse(JSON.stringify(packagedTemplateWithUserAsParam));
        const rosaeNlgVersion = rosaeNlgFeatures === null || rosaeNlgFeatures === void 0 ? void 0 : rosaeNlgFeatures.getRosaeNlgVersion();
        this.nlgLib = rosaeNlgFeatures === null || rosaeNlgFeatures === void 0 ? void 0 : rosaeNlgFeatures.NlgLib;
        this.templateId = this.packagedTemplateWithUser.templateId;
        this.user = this.packagedTemplateWithUser.user;
        this.format = this.packagedTemplateWithUser.format;
        console.log({ templateId: this.templateId, message: `RosaeContext constructor` });
        const packagedTemplateComp = this.packagedTemplateWithUser.comp;
        // only compile if useful
        if (packagedTemplateComp && packagedTemplateComp.compiled && packagedTemplateComp.compiled != '') {
            const compiledWithVersion = packagedTemplateComp.compiledWithVersion;
            if (!compiledWithVersion || !rosaeNlgVersion || compiledWithVersion != rosaeNlgVersion) {
                console.warn({
                    templateId: this.templateId,
                    message: `found compiled with ${compiledWithVersion} while runtime version is ${rosaeNlgVersion}; but will continue`,
                });
            }
            else {
                console.log({
                    templateId: this.templateId,
                    message: `was already compiled: ${packagedTemplateComp.compiledBy} ${packagedTemplateComp.compiledWhen} ${packagedTemplateComp.compiledWithVersion}`,
                });
            }
            this.hadToCompile = false;
        }
        else {
            console.log({ templateId: this.templateId, message: 'should compile as no compiled content found' });
            if (!rosaeNlgFeatures || rosaeNlgFeatures.compileFileClient == null) {
                console.log({
                    templateId: this.templateId,
                    message: `was not compiled but could not find compiler`,
                });
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = `cannot compile because no compiler found`;
                throw err;
            }
            else {
                // ok, compile
                try {
                    // activate comp if not already activated
                    this.packagedTemplateWithUser.src.compileInfo.activate = true;
                    rosaenlg_packager_1.completePackagedTemplateJson(this.packagedTemplateWithUser, rosaeNlgFeatures);
                    console.log({
                        templateId: this.templateId,
                        message: `properly compiled with RosaeNLG version ${rosaeNlgVersion}`,
                    });
                }
                catch (e) {
                    const err = new Error();
                    err.name = 'InvalidArgumentError';
                    err.message = `cannot compile: ${e.message}`;
                    throw err;
                }
                this.hadToCompile = true;
            }
        }
        this.compiledFct = new Function('params', `${this.packagedTemplateWithUser.comp.compiled}; return template(params);`);
        // autotest if we had to compile AND if we could compile, otherwise we don't care no more
        if (this.hadToCompile && this.compiledFct) {
            const autotest = this.packagedTemplateWithUser.src.autotest;
            if (autotest != null && autotest.activate) {
                console.log({ templateId: this.templateId, message: `autotest is activated` });
                let renderedBundle;
                try {
                    renderedBundle = this.render(autotest.input);
                }
                catch (e) {
                    const err = new Error();
                    err.name = 'InvalidArgumentError';
                    err.message = `cannot render autotest: ${e.message}`;
                    throw err;
                }
                for (let i = 0; i < autotest.expected.length; i++) {
                    const expectedElt = autotest.expected[i];
                    if (renderedBundle.text.indexOf(expectedElt) == -1) {
                        const err = new Error();
                        err.name = 'InvalidArgumentError';
                        err.message = `autotest failed on ${expectedElt}:` + ` rendered was ${renderedBundle.text}`;
                        throw err;
                    }
                }
                // everything went ok
            }
        }
    }
    render(originalOptions) {
        // we clone as rendering tends to change data
        const options = JSON.parse(JSON.stringify(originalOptions));
        const renderOptions = new RenderOptions_1.RenderOptions(options);
        try {
            options.util = new this.nlgLib(renderOptions);
            return {
                text: this.compiledFct(options),
                renderOptions: renderOptions,
            };
        }
        catch (e) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `cannot render: ${e.message}`;
            throw err;
        }
        finally {
            // must not alter options!
            delete options.util;
        }
    }
    getTemplateId() {
        return this.templateId;
    }
    getFullTemplate() {
        return this.packagedTemplateWithUser;
    }
    getSha1() {
        return crypto_1.createHash('sha1').update(JSON.stringify(this.packagedTemplateWithUser.src)).digest('hex');
    }
}
exports.RosaeContext = RosaeContext;
//# sourceMappingURL=RosaeContext.js.map