"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const RosaeContextsManager_1 = require("./RosaeContextsManager");
class DiskRosaeContextsManager extends RosaeContextsManager_1.RosaeContextsManager {
    constructor(templatesPath, rosaeNlgFeatures, rosaeContextsManagerParams) {
        super(rosaeContextsManagerParams);
        this.templatesPath = templatesPath;
        this.rosaeNlgFeatures = rosaeNlgFeatures;
        console.info({
            action: 'configure',
            message: `templates path is ${this.templatesPath}`,
        });
    }
    hasBackend() {
        return true;
    }
    checkHealth(cb) {
        const filename = `${this.templatesPath}/health_${this.getKindOfUuid()}.tmp`;
        const content = 'health check';
        fs.writeFile(filename, content, 'utf8', (err) => {
            if (err) {
                cb(err);
                return;
            }
            else {
                fs.unlink(filename, () => {
                    cb(null);
                    return;
                });
            }
        });
    }
    getFilename(user, templateId) {
        return user + '#' + templateId + '.json';
    }
    getAllFiles(cb) {
        fs.readdir(this.templatesPath, (err, files) => {
            if (err) {
                console.error({
                    message: `cannot read disk: ${err}`,
                });
                cb(err, null);
            }
            else {
                cb(null, files);
            }
        });
    }
    readTemplateOnBackend(user, templateId, cb) {
        const entryKey = this.getFilename(user, templateId);
        fs.readFile(`${this.templatesPath}/${entryKey}`, 'utf8', (readFileErr, rawTemplateContent) => {
            if (readFileErr) {
                // does not exist: we don't care, don't even log
                const e = new Error();
                e.name = '404';
                e.message = `${entryKey} not found on disk: ${readFileErr.message}`;
                cb(e, null);
                return;
            }
            else {
                let parsed;
                try {
                    parsed = JSON.parse(rawTemplateContent);
                }
                catch (parseErr) {
                    const e = new Error();
                    e.name = '500';
                    e.message = `could not parse: ${parseErr}`;
                    cb(e, null);
                    return;
                }
                cb(null, parsed);
                return;
            }
        });
    }
    getUserAndTemplateId(filename) {
        return this.getUserAndTemplateIdHelper(filename, '#');
    }
    saveOnBackend(filename, content, cb) {
        fs.writeFile(`${this.templatesPath}/${filename}`, content, 'utf8', (err) => {
            cb(err);
        });
    }
    deleteFromBackend(filename, cb) {
        // delete the file
        const fileToDelete = `${this.templatesPath}/${filename}`;
        fs.unlink(fileToDelete, (err) => {
            cb(err);
        });
    }
}
exports.DiskRosaeContextsManager = DiskRosaeContextsManager;
//# sourceMappingURL=DiskRosaeContextsManager.js.map