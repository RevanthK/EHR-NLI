"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aws = require("aws-sdk");
const RosaeContextsManager_1 = require("./RosaeContextsManager");
class S3RosaeContextsManager extends RosaeContextsManager_1.RosaeContextsManager {
    constructor(s3Conf, rosaeNlgFeatures, rosaeContextsManagerParams) {
        super(rosaeContextsManagerParams);
        this.configureS3(s3Conf);
        this.rosaeNlgFeatures = rosaeNlgFeatures;
    }
    configureS3(s3Conf) {
        const s3config = {
            s3ForcePathStyle: true,
        };
        s3config.accessKeyId = s3Conf.accessKeyId;
        s3config.secretAccessKey = s3Conf.secretAccessKey;
        // when testing using s3rver
        if (s3Conf.endpoint) {
            s3config.endpoint = s3Conf.endpoint;
        }
        this.s3 = new aws.S3(s3config);
        this.bucket = s3Conf.bucket;
        console.info({
            action: 'configureS3',
            message: `bucket is ${this.bucket}`,
        });
    }
    hasBackend() {
        return true;
    }
    checkHealth(cb) {
        const filename = `health_${this.getKindOfUuid()}.tmp`;
        const content = 'health check';
        this.s3.upload({
            Bucket: this.bucket,
            Key: filename,
            Body: content,
        }, (err) => {
            if (err) {
                cb(err);
                return;
            }
            else {
                this.s3.deleteObject({ Bucket: this.bucket, Key: filename }, () => {
                    cb(null);
                    return;
                });
            }
        });
    }
    getFilename(user, templateId) {
        return user + '/' + templateId + '.json';
    }
    getAllFiles(cb) {
        this.s3.listObjectsV2({ Bucket: this.bucket }, (err, data) => {
            if (err) {
                console.error({
                    message: `s3 did not respond properly: ${err}`,
                });
                const e = new Error();
                e.message = `s3 did not respond properly: ${err}`;
                cb(err, null);
            }
            else {
                /* istanbul ignore if */
                if (data.IsTruncated) {
                    console.error({
                        message: `s3 response is truncated`,
                    });
                    const e = new Error();
                    e.message = `s3 response is truncated`;
                    cb(err, null);
                }
                else {
                    const files = [];
                    for (let i = 0; i < data.Contents.length; i++) {
                        files.push(data.Contents[i].Key);
                    }
                    cb(null, files);
                }
            }
        });
    }
    readTemplateOnBackend(user, templateId, cb) {
        const entryKey = this.getFilename(user, templateId);
        this.s3.getObject({
            Bucket: this.bucket,
            Key: entryKey,
        }, (s3err, data) => {
            if (s3err) {
                // does not exist: we don't care, don't even log
                const e = new Error();
                e.name = '404';
                e.message = `${entryKey} not found on s3: ${s3err.message}`;
                cb(e, null);
                return;
            }
            else {
                const rawTemplateData = data.Body.toString();
                let parsed;
                try {
                    parsed = JSON.parse(rawTemplateData);
                }
                catch (parseErr) {
                    const e = new Error();
                    e.name = '500';
                    e.message = `could not parse: ${parseErr}`;
                    cb(e, null);
                    return;
                }
                cb(null, parsed);
                return;
            }
        });
    }
    getUserAndTemplateId(filename) {
        return this.getUserAndTemplateIdHelper(filename, '/');
    }
    saveOnBackend(filename, content, cb) {
        this.s3.upload({
            Bucket: this.bucket,
            Key: filename,
            Body: content,
        }, (err, _data) => {
            cb(err);
        });
    }
    deleteFromBackend(filename, cb) {
        this.s3.deleteObject({ Bucket: this.bucket, Key: filename }, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        (err, _data) => {
            cb(err);
        });
    }
}
exports.S3RosaeContextsManager = S3RosaeContextsManager;
//# sourceMappingURL=S3RosaeContextsManager.js.map