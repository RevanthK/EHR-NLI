"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const NodeCache = require("node-cache");
const RosaeContext_1 = require("./RosaeContext");
const process = __importStar(require("process"));
class RosaeContextsManager {
    constructor(rosaeContextsManagerParams) {
        this.ttl = rosaeContextsManagerParams.specificTtl || 600; // 10 minutes
        this.cacheCheckPeriod = rosaeContextsManagerParams.specificCheckPeriod || 60; // 1 minute
        this.forgetTemplates = rosaeContextsManagerParams.forgetTemplates;
        this.enableCache = rosaeContextsManagerParams.enableCache != null ? rosaeContextsManagerParams.enableCache : true; // enabled by default
        // this.origin = rosaeContextsManagerParams.origin;
        this.rosaeContextsCache = new NodeCache({
            checkperiod: this.cacheCheckPeriod,
            useClones: false,
            deleteOnExpire: true,
        });
    }
    readTemplateOnBackendAndLoad(user, templateId, cb) {
        this.readTemplateOnBackend(user, templateId, (err, templateContent) => {
            if (err) {
                console.warn({
                    action: 'load',
                    user: user,
                    templateId: templateId,
                    message: `could not reload: ${err}`,
                });
                cb(err, null);
            }
            else {
                this.compSaveAndLoad(templateContent, false, (loadErr, templateSha1, _rosaeContext) => {
                    cb(loadErr, templateSha1);
                });
            }
        });
    }
    reloadAllFiles(cb) {
        this.getAllFiles((err, files) => {
            if (err) {
                cb(err);
            }
            else {
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const userAndTemplateId = this.getUserAndTemplateId(file);
                    if (userAndTemplateId && userAndTemplateId.user && userAndTemplateId.templateId) {
                        this.readTemplateOnBackendAndLoad(userAndTemplateId.user, userAndTemplateId.templateId, (_err, _templateSha1) => {
                            // do nothing with the error
                        });
                    }
                    else {
                        console.warn({
                            action: 'startup',
                            message: `invalid file: ${file}`,
                        });
                    }
                }
                cb(null);
            }
        });
    }
    getFromCacheOrLoad(user, templateId, askedSha1, cb) {
        if ((askedSha1 && this.isInCacheWithGoodSha1(user, templateId, askedSha1)) ||
            (!askedSha1 && this.isInCache(user, templateId))) {
            // already in cache with the proper sha1?
            cb(null, this.getFromCache(user, templateId));
            return;
        }
        else {
            this.readTemplateOnBackend(user, templateId, (readTemplateErr, templateContent) => {
                if (readTemplateErr) {
                    // does not exist: we don't really care
                    console.log({
                        user: user,
                        templateId: templateId,
                        action: 'getFromCacheOrLoad',
                        message: `error: ${readTemplateErr}`,
                    });
                    const e = new Error();
                    e.name = '404';
                    e.message = `${user} ${templateId} not found on backend: ${readTemplateErr.message}`;
                    cb(e, null);
                    return;
                }
                else {
                    templateContent.user = user;
                    this.compSaveAndLoad(templateContent, false, (compErr, loadedSha1, rosaeContext) => {
                        if (compErr) {
                            const e = new Error();
                            e.name = '400';
                            e.message = `no existing compiled content for ${templateId}, and could not compile: ${compErr}`;
                            cb(e, null);
                            return;
                        }
                        if (askedSha1 && loadedSha1 != askedSha1) {
                            const e = new Error();
                            e.name = '404';
                            e.message = `sha1 do not correspond, read sha1 is ${loadedSha1} while requested is ${askedSha1}`;
                            cb(e, null);
                            return;
                        }
                        // everything is ok
                        cb(null, {
                            templateSha1: loadedSha1,
                            rosaeContext: rosaeContext,
                        });
                    });
                }
            });
        }
    }
    deleteFromCacheAndBackend(user, templateId, cb) {
        if (this.enableCache) {
            this.deleteFromCache(user, templateId);
        }
        if (this.hasBackend()) {
            const filename = this.getFilename(user, templateId);
            this.deleteFromBackend(filename, (err) => {
                if (err) {
                    console.log({ user: user, templateId: templateId, action: 'delete', message: `failed: ${err}` });
                    const e = new Error();
                    //e.name = '500';
                    e.message = `delete failed: ${err}`;
                    cb(e);
                    return;
                }
                else {
                    console.log({ user: user, templateId: templateId, action: 'delete', message: `done.` });
                    cb(null);
                    return;
                }
            });
        }
        else {
            cb(null);
        }
    }
    getKindOfUuid() {
        return `${process.pid}-${Math.floor(Math.random() * 100000)}`; //NOSONAR
    }
    compSaveAndLoad(templateContent, alwaysSave, cb) {
        const user = templateContent.user;
        let rosaeContext;
        try {
            rosaeContext = new RosaeContext_1.RosaeContext(templateContent, this.rosaeNlgFeatures);
        }
        catch (e) {
            console.log({
                user: user,
                action: 'create',
                message: `error creating template: ${e.message}`,
            });
            const err = new Error();
            err.name = '400';
            err.message = e.message;
            cb(err, null, null);
            return;
        }
        const templateId = rosaeContext.getTemplateId();
        if (!templateId) {
            const err = new Error();
            err.name = '400';
            err.message = 'no templateId!';
            cb(err, null, null);
            console.log({ user: user, action: 'create', message: `no templateId` });
            return;
        }
        else {
            const templateSha1 = rosaeContext.getSha1();
            const cacheValue = {
                templateSha1: templateSha1,
                rosaeContext: rosaeContext,
            };
            if (this.enableCache) {
                this.setInCache(user, templateId, cacheValue, false);
            }
            if (this.hasBackend() && (alwaysSave || rosaeContext.hadToCompile)) {
                const filename = this.getFilename(user, templateId);
                this.saveOnBackend(filename, JSON.stringify(rosaeContext.getFullTemplate()), (err) => {
                    if (err) {
                        console.error({
                            user: user,
                            action: 'create',
                            sha1: templateSha1,
                            message: `could not save to backend: ${err}`,
                        });
                        const e = new Error();
                        e.name = '500';
                        e.message = 'could not save to backend';
                        cb(e, null, null);
                    }
                    else {
                        console.log({
                            user: user,
                            action: 'create',
                            sha1: templateSha1,
                            message: `saved to backend ${filename}`,
                        });
                        cb(null, templateSha1, rosaeContext);
                    }
                });
            }
            else {
                cb(null, templateSha1, rosaeContext);
            }
        }
    }
    getIdsFromBackend(user, cb) {
        this.getAllFiles((err, files) => {
            if (err) {
                cb(err, null);
            }
            else {
                const ids = [];
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const userAndTemplateId = this.getUserAndTemplateId(file);
                    if (userAndTemplateId && userAndTemplateId.user == user && userAndTemplateId.templateId) {
                        ids.push(userAndTemplateId.templateId);
                    }
                }
                cb(null, ids);
            }
        });
    }
    getUserAndTemplateIdHelper(filename, sep) {
        const splited = filename.split(sep);
        if (splited.length != 2) {
            console.error({
                message: `invalid file: ${splited}`,
            });
            return null;
        }
        return { user: splited[0], templateId: splited[1].replace(/\.json$/, '') };
    }
    checkCacheEnable() {
        if (!this.enableCache) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `trying to use cache but enableCache is false`;
            throw err;
        }
    }
    getCacheKey(user, templateId) {
        this.checkCacheEnable();
        const key = JSON.stringify({
            user: user,
            templateId: templateId,
        });
        const currTtl = this.rosaeContextsCache.getTtl(key);
        if (currTtl == undefined) {
            // not in cache yet, don't do anything
        }
        else if (currTtl == 0) {
            // no TTl, we don't change it
        }
        else {
            // reset ttl
            this.rosaeContextsCache.ttl(key, this.ttl);
        }
        return key;
    }
    getFromCache(user, templateId) {
        this.checkCacheEnable();
        return this.rosaeContextsCache.get(this.getCacheKey(user, templateId));
    }
    isInCache(user, templateId) {
        this.checkCacheEnable();
        return this.rosaeContextsCache.has(this.getCacheKey(user, templateId));
    }
    isInCacheWithGoodSha1(user, templateId, templateSha1) {
        this.checkCacheEnable();
        const cacheValue = this.getFromCache(user, templateId);
        if (!cacheValue) {
            return false;
        }
        else {
            if (cacheValue.templateSha1 === templateSha1) {
                return true;
            }
            else {
                return false;
            }
        }
    }
    setInCache(user, templateId, cacheValue, isTemp) {
        this.checkCacheEnable();
        let ttl;
        if (isTemp || this.forgetTemplates) {
            ttl = this.ttl;
        }
        else {
            ttl = 0;
        }
        this.rosaeContextsCache.set(this.getCacheKey(user, templateId), cacheValue, ttl);
    }
    deleteFromCache(user, templateId) {
        this.checkCacheEnable();
        this.rosaeContextsCache.del(this.getCacheKey(user, templateId));
    }
    getIdsInCache(user) {
        this.checkCacheEnable();
        const cacheKeys = Array.from(this.rosaeContextsCache.keys());
        const ids = [];
        for (let i = 0; i < cacheKeys.length; i++) {
            const rawCacheKey = cacheKeys[i];
            const cacheKey = JSON.parse(rawCacheKey);
            // we don't keep temp ones
            if (cacheKey.user == user && this.rosaeContextsCache.getTtl(rawCacheKey) == 0) {
                ids.push(cacheKey.templateId);
            }
        }
        return ids;
    }
}
exports.RosaeContextsManager = RosaeContextsManager;
//# sourceMappingURL=RosaeContextsManager.js.map