"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const french_verbs_1 = require("french-verbs");
const french_verbs_lefff_1 = __importDefault(require("french-verbs-lefff"));
const german_verbs_1 = require("german-verbs");
const german_verbs_dict_1 = __importDefault(require("german-verbs-dict"));
const italian_verbs_1 = require("italian-verbs");
const italian_verbs_dict_1 = __importDefault(require("italian-verbs-dict"));
const english_verbs_helper_1 = require("english-verbs-helper");
const english_verbs_irregular_1 = __importDefault(require("english-verbs-irregular"));
const english_verbs_gerunds_1 = __importDefault(require("english-verbs-gerunds"));
class VerbsManager {
    constructor(language, genderNumberManager) {
        this.language = language;
        this.genderNumberManager = genderNumberManager;
        this.verbParts = [];
        // create English combined resource
        if (this.language === 'en_US') {
            this.mergedVerbsDataEn = english_verbs_helper_1.mergeVerbsData(english_verbs_irregular_1.default, english_verbs_gerunds_1.default);
        }
    }
    getVerbPartsList() {
        return this.verbParts;
    }
    setVerbPartsList(verbParts) {
        this.verbParts = verbParts;
    }
    setEmbeddedVerbs(embeddedVerbs) {
        this.embeddedVerbs = embeddedVerbs;
    }
    setSpy(spy) {
        this.spy = spy;
    }
    getAgreeVerb(subject, conjParams) {
        if (this.spy.isEvaluatingEmpty()) {
            return 'SOME_VERB';
        }
        else {
            const verbName = typeof conjParams === 'string' ? conjParams : conjParams.verb;
            if (!verbName) {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = `verb needed`;
                throw err;
            }
            let tense;
            if (conjParams && conjParams.tense) {
                tense = conjParams.tense;
            }
            else {
                const defaultTenses = {
                    en_US: 'PRESENT',
                    fr_FR: 'PRESENT',
                    de_DE: 'PRASENS',
                    it_IT: 'PRESENTE',
                };
                tense = defaultTenses[this.language];
            }
            const number = this.genderNumberManager.getRefNumber(subject, null) || 'S';
            //console.log(`${this.language} ${JSON.stringify(subject)} > ${number}`);
            // debug('verb=' + verbName + ' tense=' + tense + ' params: ' + JSON.stringify(ConjParams));
            const leftParams = typeof conjParams === 'string' ? null : conjParams;
            switch (this.language) {
                case 'en_US':
                    return this.getConjugationEn(verbName, tense, number, leftParams);
                case 'fr_FR':
                    return this.getConjugationFr(subject, verbName, tense, number, leftParams);
                case 'de_DE':
                    return this.getConjugationDe(verbName, tense, number, leftParams);
                case 'it_IT':
                    return this.getConjugationIt(verbName, tense, number, leftParams);
                default: {
                    const err = new Error();
                    err.name = 'InvalidArgumentError';
                    err.message = `verbs not available in ${this.language}`;
                    throw err;
                }
            }
        }
    }
    popVerbPart() {
        if (this.language != 'de_DE') {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `verbPart is only meaningful for de_DE language, not for ${this.language}`;
            throw err;
        }
        const verb = this.verbParts.pop();
        if (!verb) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `verbPart nothing to pop`;
            throw err;
        }
        return verb;
    }
    getConjugationDe(verb, tense, number, conjParams) {
        const tensesWithParts = [
            'FUTUR1',
            'FUTUR2',
            'PERFEKT',
            'PLUSQUAMPERFEKT',
            'KONJUNKTIV1_FUTUR1',
            'KONJUNKTIV1_PERFEKT',
            'KONJUNKTIV2_FUTUR1',
            'KONJUNKTIV2_FUTUR2',
        ];
        let pronominal = false;
        let pronominalCase;
        if (conjParams && conjParams.pronominal) {
            pronominal = true;
            pronominalCase = conjParams.pronominalCase;
        }
        //console.log('before calling libGetConjugationDe: ' + number);
        if (tensesWithParts.indexOf(tense) > -1) {
            // 'wird sein'
            // istanbul ignore next
            const aux = conjParams ? conjParams.aux : null;
            const conjElts = german_verbs_1.getConjugation(this.embeddedVerbs || german_verbs_dict_1.default, verb, tense, // as GermanTense
            3, number, aux, pronominal, pronominalCase);
            this.verbParts.push(conjElts.slice(1).join('¤')); // FUTUR2: 'wird gedacht haben'
            return conjElts[0];
        }
        else {
            return german_verbs_1.getConjugation(this.embeddedVerbs || german_verbs_dict_1.default, verb, tense, // as GermanTense
            3, number, null, pronominal, pronominalCase).join('¤');
        }
    }
    getConjugationFr(subject, verb, tense, number, conjParams) {
        let person;
        if (number === 'P') {
            person = 5;
        }
        else {
            person = 2;
        }
        let pronominal;
        if (conjParams && conjParams.pronominal) {
            pronominal = true;
        }
        let aux;
        if (conjParams && conjParams.aux) {
            aux = conjParams.aux;
        }
        let agreeGender;
        let agreeNumber;
        if (conjParams && conjParams.agree) {
            agreeGender = this.genderNumberManager.getRefGender(conjParams.agree, null);
            agreeNumber = this.genderNumberManager.getRefNumber(conjParams.agree, null);
        }
        else if (tense === 'PASSE_COMPOSE' || tense === 'PLUS_QUE_PARFAIT') {
            // no explicit "agree" param, but aux is ETRE, either clearly stated or is default,
            // then agreement of the participle must be automatic
            if (aux === 'ETRE' || french_verbs_1.alwaysAuxEtre(verb)) {
                agreeGender = this.genderNumberManager.getRefGender(subject, null);
                agreeNumber = this.genderNumberManager.getRefNumber(subject, null);
            }
        }
        // also give the verbs that we embedded in the compiled template, if there are some
        const verbsSpecificList = this.embeddedVerbs;
        //console.log(`verbsSpecificList: ${JSON.stringify(params.verbsSpecificList)}`);
        return french_verbs_1.getConjugation(verbsSpecificList || french_verbs_lefff_1.default, // if nothing we use the lefff
        verb, tense, person, aux, agreeGender, agreeNumber, pronominal);
    }
    getConjugationIt(verb, tense, number, conjParams) {
        let aux;
        if (conjParams && conjParams.aux) {
            aux = conjParams.aux;
        }
        let agreeGender;
        let agreeNumber;
        if (conjParams && conjParams.agree) {
            agreeGender = this.genderNumberManager.getRefGender(conjParams.agree, null);
            agreeNumber = this.genderNumberManager.getRefNumber(conjParams.agree, null);
        }
        // also give the verbs that we embedded in the compiled template, if there are some
        const verbsSpecificList = this.embeddedVerbs;
        //console.log(`verbsSpecificList: ${JSON.stringify(params.verbsSpecificList)}`);
        return italian_verbs_1.getConjugation(verbsSpecificList || italian_verbs_dict_1.default, verb, tense, 3, number, aux, agreeGender, agreeNumber);
    }
    getConjugationEn(verb, tense, number, leftParams) {
        const verbsSpecificList = this.embeddedVerbs;
        return english_verbs_helper_1.getConjugation(verbsSpecificList || this.mergedVerbsDataEn, verb, tense, number, leftParams);
    }
}
exports.VerbsManager = VerbsManager;
//# sourceMappingURL=VerbsManager.js.map