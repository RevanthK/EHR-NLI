"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class SavePoint {
    constructor(htmlBefore, context, hasSaid, triggeredRefs, refGenderMap, refNumberMap, rndNextPos, nextRefs, synoSeq, synoTriggered, verbParts) {
        // here we have to copy
        this.htmlBefore = htmlBefore;
        this.context = context;
        this.hasSaid = Object.assign({}, hasSaid);
        this.triggeredRefs = new Map(triggeredRefs);
        this.refGenderMap = new Map(refGenderMap);
        this.refNumberMap = new Map(refNumberMap);
        this.rndNextPos = rndNextPos;
        this.nextRefs = new Map(nextRefs);
        this.synoSeq = new Map(synoSeq);
        // deep copy of the values in the array
        this.synoTriggered = new Map();
        for (const key of synoTriggered.keys()) {
            this.synoTriggered.set(key, [...synoTriggered.get(key)]);
        }
        this.verbParts = verbParts.slice(0);
    }
}
class SaveRollbackManager {
    constructor() {
        this.savePoints = [];
    }
    bindObjects(saidManager, refsManager, genderNumberManager, randomManager, synManager, verbsManager) {
        this.saidManager = saidManager;
        this.refsManager = refsManager;
        this.genderNumberManager = genderNumberManager;
        this.randomManager = randomManager;
        this.synManager = synManager;
        this.verbsManager = verbsManager;
    }
    setSpy(spy) {
        this.spy = spy;
    }
    /*
    deleteRollback(): void {
      this.savePoints.pop();
    }
    */
    saveSituation(context) {
        // debug('SAVING DATA');
        // debug(this.spy);
        // no need to copy the objects here, just give their reference
        const savePoint = new SavePoint(this.spy.getPugHtml(), context, this.saidManager.getHasSaidMap(), this.refsManager.getTriggeredRefs(), this.genderNumberManager.getRefGenderMap(), this.genderNumberManager.getRefNumberMap(), this.randomManager.getRndNextPos(), this.refsManager.getNextRefs(), this.synManager.getSynoSeq(), this.synManager.getSynoTriggered(), this.verbsManager.getVerbPartsList());
        // debug('WHEN SAVING: ' + JSON.stringify(this.savePoints));
        this.savePoints.push(savePoint);
        switch (savePoint.context) {
            case 'isEmpty': {
                this.isEvaluatingEmpty = true;
                break;
            }
            case 'nextRep': {
                this.isEvaluatingNextRep = true;
                break;
            }
            case 'choosebest': {
                this.isEvaluatingChoosebest = true;
                break;
            }
        }
    }
    rollback() {
        // debug('ROLLBACK DATA');
        // debug('ROLLBACK DATA: size ' + this.savePoints.length);
        const savePoint = this.savePoints.pop();
        // debug('SAVEPOINT CONTENT: ' + JSON.stringify(savePoint));
        // there's no point in creating new maps here: we just reuse the ones we created before
        this.saidManager.setHasSaidMap(savePoint.hasSaid);
        this.refsManager.setTriggeredRefs(savePoint.triggeredRefs);
        this.genderNumberManager.setRefGenderMap(savePoint.refGenderMap);
        this.genderNumberManager.setRefNumberMap(savePoint.refNumberMap);
        this.randomManager.setRndNextPos(savePoint.rndNextPos);
        this.refsManager.setNextRefs(savePoint.nextRefs);
        this.synManager.setSynoSeq(savePoint.synoSeq);
        this.synManager.setSynoTriggered(savePoint.synoTriggered);
        this.verbsManager.setVerbPartsList(savePoint.verbParts);
        switch (savePoint.context) {
            case 'isEmpty': {
                this.isEvaluatingEmpty = false;
                break;
            }
            case 'nextRep': {
                this.isEvaluatingNextRep = false;
                break;
            }
            case 'choosebest': {
                this.isEvaluatingChoosebest = false;
                break;
            }
        }
        this.spy.setPugHtml(savePoint.htmlBefore);
    }
}
exports.SaveRollbackManager = SaveRollbackManager;
//# sourceMappingURL=SaveRollbackManager.js.map