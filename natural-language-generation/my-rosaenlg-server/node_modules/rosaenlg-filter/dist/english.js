"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const english_a_an_list_1 = __importDefault(require("english-a-an-list"));
const english_a_an_1 = require("english-a-an");
const constants_1 = require("./constants");
function redoCapitalization(initial, replacement) {
    if (initial === 'A') {
        return replacement.substring(0, 1).toUpperCase() + replacement.substring(1); // A or An...
    }
    else {
        return replacement;
    }
}
// quite the same as aAn but works when the string is protected
function aAnBeforeProtect(input) {
    let res = input;
    //console.log('xxx' + input);
    const regexA = new RegExp(`([^${constants_1.tousCaracteresMinMajRe}])([aA])${constants_1.stdBetweenWithParenthesis}§¤*([${constants_1.tousCaracteresMinMajRe}]*)`, 'g');
    res = res.replace(regexA, function (match, before, aA, between, word) {
        // console.log(`BEFORE PROTECT <${before}> <${aA}> <${between}> <${word}>`);
        if (word != null && word != '') {
            // can be null when orphan "a" at the very end of a text
            const newAa = redoCapitalization(aA, english_a_an_1.getAAn(english_a_an_list_1.default, word));
            return `${before}${newAa}${between}§${word}`;
        }
        else {
            return match;
        }
    });
    //console.log('yyy' + res);
    return res;
}
exports.aAnBeforeProtect = aAnBeforeProtect;
function aAn(input) {
    let res = input;
    const regexA = new RegExp(`([^${constants_1.tousCaracteresMinMajRe}])([aA])${constants_1.stdBetweenWithParenthesis}([${constants_1.tousCaracteresMinMajRe}]*)`, 'g');
    res = res.replace(regexA, function (match, before, aA, between, word) {
        // console.log(`NORMAL <${input}> <${before}> <${aA}> <${between}> <${word}>`);
        if (word != null && word != '') {
            // can be null when orphan "a" at the very end of a text
            const newAa = redoCapitalization(aA, english_a_an_1.getAAn(english_a_an_list_1.default, word));
            return `${before}${newAa}${between}${word}`; // NOT the same return as above
        }
        else {
            return match;
        }
    });
    return res;
}
exports.aAn = aAn;
function enPossessivesBeforeProtect(input) {
    let res = input;
    // debug("xx: "+ input);
    const regexSS = new RegExp("(s\\s*§[\\s¤]*'s)([^" + constants_1.tousCaracteresMinMajRe + '])', 'g');
    res = res.replace(regexSS, function (corresp, first, second) {
        // debug(`AAAA ${corresp} ${first} ${offset} ${orig}`);
        return `s§' ${second}`;
    });
    // debug("yy: "+ res);
    return res;
}
exports.enPossessivesBeforeProtect = enPossessivesBeforeProtect;
function enPossessives(input) {
    let res = input;
    // debug("xx: "+ input);
    // the <b>earrings</b> 's size => The <b>earrings</b>' size
    const regexSS = new RegExp("s([☞☜\\s]*)'s([^" + constants_1.tousCaracteresMinMajRe + '])', 'g');
    res = res.replace(regexSS, function (match, between, after) {
        // debug(`${corresp} ${first} ${offset} ${orig}`);
        return `s${between}'${after}`;
    });
    return res;
}
exports.enPossessives = enPossessives;
//# sourceMappingURL=english.js.map