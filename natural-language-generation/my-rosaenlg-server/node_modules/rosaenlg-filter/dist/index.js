"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const italian_1 = require("./italian");
const french_1 = require("./french");
const punctuation = __importStar(require("./punctuation"));
const clean = __importStar(require("./clean"));
const english = __importStar(require("./english"));
const titlecase_1 = require("./titlecase");
const protect = __importStar(require("./protect"));
const html = __importStar(require("./html"));
exports.blockLevelHtmlElts = html.blockLevelElts;
exports.inlineHtmlElts = html.inlineElts;
exports.EATSPACE = punctuation.EATSPACE;
//import * as Debug from 'debug';
//const debug = Debug('rosaenlg-filter');
function applyFilters(input, toApply, language) {
    let res = input;
    for (let i = 0; i < toApply.length; i++) {
        res = toApply[i](res, language);
        // debug(`after: ${res}`);
    }
    return res;
}
function egg(input /*, lang: string*/) {
    let res = input;
    const x = '\x41\x64\x64\x76\x65\x6E\x74\x61';
    const regex = new RegExp(x, 'g');
    res = res.replace(regex, x + ' 👍');
    return res;
}
function contractions(input, lang) {
    switch (lang) {
        case 'it_IT':
            return italian_1.contractions(input);
        case 'fr_FR':
            return french_1.contractions(input);
        case 'en_US':
        case 'de_DE':
        default:
            return input;
    }
}
function filter(input, language) {
    // debug('FILTER CALL');
    //console.log('FILTERING ' + input);
    let res = input;
    // PROTECT HTML SEQ
    res = html.protectHtmlEscapeSeq(res);
    // PROTECT HTML TAGS
    const replacedHtml = html.replaceHtml(res);
    res = replacedHtml.replaced;
    // ADD START to avoid the problem of the ^ in regexp
    res = 'START. ' + res;
    if (language === 'en_US') {
        res = applyFilters(res, [english.aAnBeforeProtect, english.enPossessivesBeforeProtect], 'en_US');
    }
    // PROTECT § BLOCKS
    const protectedMappings = protect.protectBlocks(res);
    res = protectedMappings.protectedString;
    res = applyFilters(res, [
        clean.joinLines,
        clean.specialSpacesToNormalSpaces,
        punctuation.duplicatePunctuation,
        contractions,
        clean.cleanStruct,
        punctuation.parenthesis,
        punctuation.quotes,
        punctuation.cleanSpacesPunctuation,
        punctuation.addCaps,
        egg,
        titlecase_1.titlecase,
    ], language);
    if (language === 'en_US') {
        res = applyFilters(res, [english.aAn, english.enPossessives], 'en_US');
    }
    // UNPROTECT § BLOCKS
    res = protect.unprotect(res, protectedMappings.mappings);
    // REMOVE START - has to be before UNPROTECT HTML TAGS
    const regexRemoveStart = new RegExp('^START([☞\\s\\.]+)', 'g');
    res = res.replace(regexRemoveStart, function (match, before) {
        return `${before.replace(/[\s\.]*/g, '')}`;
    });
    // UNPROTECT HTML TAGS
    res = html.replacePlaceholders(res, replacedHtml.elts);
    res = applyFilters(res, [clean.cleanStructAfterUnprotect], language);
    // UNPROTECT HTML SEQ
    res = html.unProtectHtmlEscapeSeq(res);
    // REMOVE spaces at the beginning and at the end
    res = res.trim();
    return res;
}
exports.filter = filter;
//# sourceMappingURL=index.js.map